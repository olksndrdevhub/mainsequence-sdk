{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to the Main Sequence Python SDK","text":"<p>The Main Sequence Python SDK is a powerful set of client libraries designed to facilitate interaction with Main Sequence systems using Python. The SDK covers three main components:</p> <ol> <li>TDAG: A time-directed acyclic graph system for managing complex, time-sensitive data pipelines.</li> <li>TDAG Client: A set of client methods to interact with the TDAG backend.</li> <li>VAM Client: A set of client methods to interact with the VAM backend.</li> </ol> <p>Several workflows demonstrating the usage of the SDK can be found in our example repository.</p>"},{"location":"#what-is-tdag","title":"What is TDAG?","text":"<p>At its core, TDAG leverages the power of DAGs (Directed Acyclic Graphs). A DAG is a graph with nodes connected by edges, where the edges have a direction, and no cycles (loops) exist. In simpler terms, this structure allows data to flow in one direction without any feedback loops, which is essential for building reliable and predictable data pipelines. The \"time-directed\" aspect in TDAG makes it ideal for handling time-sensitive operations, ensuring that tasks occur in the correct sequence.</p>"},{"location":"#why-tdag","title":"Why TDAG?","text":"<p>With TDAG, you can automatically create time-based data pipelines that handle complex dependencies. The library provides features such as automatic hashing, seamless scheduling integration, and a structured approach that enhances the reliability and scalability of your pipelines.</p>"},{"location":"#key-features-of-tdag","title":"Key Features of TDAG","text":"<ul> <li>Automated Time-Based Pipelines: TDAG allows you to easily build data pipelines where tasks are executed in time order, respecting dependencies.</li> <li>Built-in Scheduling and Hashing: Pipelines are automatically hashed and scheduled for efficient execution.</li> <li>Scalable &amp; Robust: Whether you're working on small datasets or massive time-series data flows, TDAG scales to meet your needs while ensuring the entire process is fault-tolerant and robust.</li> </ul>"},{"location":"#use-case-investment-strategies-and-beyond","title":"Use Case: Investment Strategies and Beyond","text":"<p>One of TDAG's main use cases is transforming raw financial data into actionable insights, such as investment strategy predictions or portfolio weights. TDAG simplifies the process of managing complex time-based operations in financial modeling, helping you move from data to decisions effortlessly.</p> <p>However, TDAG is not just limited to finance! It's perfect for any application requiring time-sensitive data pipelines, particularly in live and online modes where real-time decision-making is crucial. For example, TDAG can be used in online training of machine learning models, where time-based data flow and immediate processing are essential for model accuracy and performance.</p>"},{"location":"#tdag-client","title":"TDAG Client","text":"<p>The TDAG Client provides the necessary methods to interact with the TDAG backend. It enables users to submit, track, and manage their TDAG-based workflows programmatically, ensuring smooth execution and monitoring of time-sensitive operations.</p>"},{"location":"#vam-client","title":"VAM Client","text":"<p>The VAM Client offers methods to interact with the VAM backend, facilitating the retrieval and processing of valuation and analytics data.  This allows seamless integration of asset valuation within the broader financial modeling ecosystem.</p>"},{"location":"#explore-more","title":"Explore More","text":"<p>To get started with the SDK and explore practical examples, check out our:</p> <ul> <li>\ud83d\udcd6 TDAG Tutorial \u2013 Start with the TDAG Tutorial if you are looking to build customized portfolios.</li> <li>\ud83d\udcc2 Example Repository \u2013 Find practical examples and workflows to kickstart your journey with the SDK.</li> </ul>"},{"location":"#sections-of-this-documentation","title":"Sections of this Documentation","text":"<ul> <li>Getting Started</li> <li>Installation</li> <li>Key Concepts</li> <li>Tutorials</li> <li>Usage Examples</li> <li>API Reference</li> <li>FAQ</li> <li>Contributing</li> <li>Changelog</li> </ul> <p>Explore the sidebar for more detailed topics and guides.</p>"},{"location":"about/","title":"About","text":"<p>TDAG is proprietary software that is part of the MainSequence SDK and is developed for use only under an explicit license agreement. The details of the license are as follows:</p> <p>MainSequence GmbH SDK License Agreement This License Agreement (the \"License\") governs the use, modification, and distribution of the software provided by MainSequence GmbH (the \"Licensor\"). The software (the \"Software\") is provided to you under the terms of this License. By using the Software, you agree to the terms of this License.</p> <p>TERMS AND CONDITIONS</p> <ol> <li>Definitions    \"Personal Use\": Use by an individual for personal purposes that are not connected to any business, organization, or    commercial activity.    \"Internal Use\": Use within a business, organization, or other entity, provided it is not made accessible to third    parties or used for commercial purposes.    \"Commercial Use\": Use of the Software in exchange for monetary or other compensation, including hosting, offering    Software as a service, selling the Software, or using it in a product or service for sale.    \"License Agreement\": The legally binding agreement between the Licensor and the licensee (you), subject to the terms    outlined in this License.</li> <li>Grant of License    1.1 Personal and Internal Use    The Licensor grants you a limited, non-exclusive, non-transferable, revocable license to use and modify the Software    for personal or internal use only, provided that such use is strictly subject to this License Agreement and continues    only while the License Agreement remains in effect.    Upon termination of this License Agreement, all rights to use the Software for personal or internal purposes shall be    immediately revoked, and you must cease all use of the Software.    1.2 Modification    You are permitted to modify the Software solely for your own personal or internal use, subject to the restrictions    outlined in this License Agreement.    You are not permitted to distribute, sublicense, or otherwise transfer modified or unmodified versions of the    Software to any third party.    1.3 Prohibited Redistribution    You may not redistribute, sublicense, sell, lease, rent, or otherwise transfer the Software, whether in its original    form or as modified by you, to any third party.    Any attempt to distribute or transfer the Software in any way, without explicit permission from MainSequence GmbH, is    strictly prohibited.</li> <li>Prohibition of Commercial Use    The Software may not be used for any commercial purposes without obtaining a separate commercial license from    MainSequence GmbH.    Examples of prohibited commercial use include, but are not limited to:    Hosting or offering the Software as a service to others, either modified or unmodified.    Using the Software as part of a commercial product or service provided to customers for a fee.    Using the Software in any production environment that generates income, directly or indirectly, from its use.</li> <li>Termination    This License Agreement will automatically terminate if you fail to comply with any of its terms.    Upon termination of this License, you must immediately cease all use of the Software, destroy all copies (modified or    unmodified), and remove the Software from any devices or systems on which it is installed.    MainSequence GmbH reserves the right to terminate this License at its discretion for any violation of its terms or    for any other reason.</li> <li>Commercial License    If you wish to use the Software for commercial purposes, you must contact MainSequence GmbH to negotiate and obtain a    separate commercial license. The terms of the commercial license, including any fees, will be negotiated separately    from this License Agreement.    Without a valid commercial license, you are strictly prohibited from using the Software for any commercial activity.</li> <li> <p>Disclaimer of Warranty    THE SOFTWARE IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. IN NO EVENT SHALL MAINSEQUENCE    GMBH OR THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,    TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    SOFTWARE.</p> </li> <li> <p>Limitation of Liability    IN NO EVENT SHALL MAINSEQUENCE GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES    ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p> </li> <li> <p>Governing Law    This License Agreement shall be governed by and construed in accordance with the laws of the jurisdiction where MainSequence GmbH is located, without regard to its conflict of law provisions.</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"contact_and_support/","title":"Contact &amp; Support","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/config/","title":"Config","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/config/#mainsequence.tdag.config","title":"<code>mainsequence.tdag.config</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/logconf/","title":"Logconf","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/logconf/#mainsequence.tdag.logconf","title":"<code>mainsequence.tdag.logconf</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/logconf/#mainsequence.tdag.logconf.console_logger","title":"<code>console_logger(logger_name, application_name, **metadata)</code>","text":"<p>Mockup logger</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/logconf/#mainsequence.tdag.logconf.create_logger_in_path","title":"<code>create_logger_in_path(logger_name, logger_file, application_name='tdag', **metadata)</code>","text":"<p>Create a logger that logs to console and file in JSON format.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/logconf/#mainsequence.tdag.logconf.extract_from_record","title":"<code>extract_from_record(_, __, event_dict)</code>","text":"<p>Extract thread and process names and add them to the event dict.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/utils/#mainsequence.tdag.utils","title":"<code>mainsequence.tdag.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/utils/#mainsequence.tdag.utils.copy_drop_database","title":"<code>copy_drop_database(source_uri, target_uri, source_container_name)</code>","text":"<p>Copies database from one host to the other and guarantees  that  are no broken time series.</p> <p>Parameters:</p> Name Type Description Default <code>source_uri</code> <code>str</code> required <code>target_uri</code> <code>str</code> required <code>source_container_name</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/utils/#mainsequence.tdag.contrib.utils","title":"<code>mainsequence.tdag.contrib.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/","title":"Bar features","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features","title":"<code>mainsequence.tdag.contrib.feature_factory.bar_features</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.AlphaRV","title":"<code>AlphaRV</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.AlphaRV.__init__","title":"<code>__init__(target_column, beta_rolling_window, include_inputs_var=False, *args, **kwargs)</code>","text":"<p>calcualtes RV of alpha by RV of its components</p> <p>Parameters:</p> Name Type Description Default <code>target_column</code> <code>int</code> required <code>upsample_window</code> required <code>alpha_rolling_window</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.BetaFactorLoading","title":"<code>BetaFactorLoading</code>","text":"<p>               Bases: <code>FeatureBase</code></p> <p>This feature makes a rolling regression of beta columns and finds the loading values for the betas on a cross sectional regression</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.DayCloseToOpenReturn","title":"<code>DayCloseToOpenReturn</code>","text":"<p>               Bases: <code>FeatureBase</code></p> <p>Calcualtes return between days from previous day close to actual day open</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.MACD_hist","title":"<code>MACD_hist</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.MACD_hist.__init__","title":"<code>__init__(fast_window, slow_window, target_column, lag, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>fast_window</code> <code>int</code> required <code>slow_window</code> <code>int</code> required <code>signal_window</code> required <code>target_column</code> <code>str</code> required <code>lag</code> <code>int</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.ReturnFromHighLows","title":"<code>ReturnFromHighLows</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.ReturnFromHighLows.__init__","title":"<code>__init__(buffer_window, numerator_column, denominator_column, agg_fun, *args, **kwargs)</code>","text":"<p>:param buffer_window: window to calculate the return from, sometimes this is needed to avoid capturing a reversal effect. :param args: :param kwargs:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingDollarValueBars","title":"<code>RollingDollarValueBars</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingDollarValueBars.get_historical_sequences","title":"<code>get_historical_sequences(df, sequence_length, target_column)</code>  <code>staticmethod</code>","text":"<p>Get data with historical sequences of desired length :param df: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingResidualAlphaBeta","title":"<code>RollingResidualAlphaBeta</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingResidualAlphaBeta.__init__","title":"<code>__init__(target_column, beta_shift=None, alpha_size=None, normalize_beta=False, upsample_regression_minutes=None, *args, **kwargs)</code>","text":"<p>:param target_column: :param beta_shift: :param alpha_size: :param args: :param kwargs:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SimpleReturn","title":"<code>SimpleReturn</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SimpleReturn.__init__","title":"<code>__init__(lag, return_window, target_column, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lag</code> <code> A positive number represents laggede returns, for example if data frequency is minute , lag is 60</code> required <code>and</code> required <code>return_window</code> <code>int</code> required <code>target_column</code> <code>str</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SmoothSpread","title":"<code>SmoothSpread</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SmoothSpread.__init__","title":"<code>__init__(target_column, *args, **kwargs)</code>","text":"<p>:param target_column: :param beta_shift: :param alpha_size: :param args: :param kwargs:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.VolumeRatio","title":"<code>VolumeRatio</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.VolumeRatio.__init__","title":"<code>__init__(target_column, numerator_window, *args, **kwargs)</code>","text":"<p>calcualtes teh rolling mean :param target_column: :param denominator_window: :param args: :param kwargs:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.get_rolling_moving_average","title":"<code>get_rolling_moving_average(old_mean, new_sample, last_sample, rolling_window)</code>","text":"<p>Calculates Rolling Moving avarega :param old_mean: :param new_sample: :param last_sample: :param rolling_windos: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/","title":"Bar time series","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series","title":"<code>mainsequence.tdag.contrib.feature_factory.bar_time_series</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CommonalityFeature","title":"<code>CommonalityFeature</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CommonalityFeature.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompAssetFeat","title":"<code>CompAssetFeat</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompAssetFeat.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompCrossAssetFeat","title":"<code>CompCrossAssetFeat</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompCrossAssetFeat.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory","title":"<code>FeaturesFactory</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory.__init__","title":"<code>__init__(features_list)</code>","text":"<p>:param features_dict: {feature_name:feature_kwargs}</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory.build_features","title":"<code>build_features(data_df, logger, upsample_frequency_id, original_latest_value, last_observation, extra_data=None)</code>","text":"<p>:param data_df: dataframe with information up to the  longest feature :param logger: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.build_features_from_upsampled_df","title":"<code>build_features_from_upsampled_df(upsampled_ts, latest_value, features_factory, logger, upsample_frequency_id, bar_frequency_id, extra_data=None, concatenate_with_source=True, last_observation=None)</code>","text":"<p>build function for Bar and portfolio Bars :param latest_value: :param features_factory: :param upsampled_df: :param upsample_frequency_id: :param bar_frequency_id: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.override_features_with_feature_frequency","title":"<code>override_features_with_feature_frequency(input_features, frequency_id, upsample_frequency_id)</code>","text":"<p>cahnges feature frequency according to upsample :param input_features: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils","title":"<code>mainsequence.tdag.contrib.feature_factory.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances","title":"<code>RollingDistances</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances.__init","title":"<code>__init(rolling_window)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>rolling_window</code> <code>int</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances.dtw","title":"<code>dtw(df)</code>","text":"<p>Calculate the rolling dynamic time warp (DTW) distances between all columns of a DataFrame.</p> <p>Parameters:     df (pandas.DataFrame): The input DataFrame containing the columns.</p> <p>Returns:     dict: A dictionary where the keys are tuples representing column pairs,           and the values are lists of DTW distances corresponding to the rolling windows.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/time_series/","title":"Time series","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series","title":"<code>mainsequence.tdag.distributed.time_series</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series.MLflowTrackingRestApi","title":"<code>MLflowTrackingRestApi</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series.MLflowTrackingRestApi.get_all_finished_runs_df","title":"<code>get_all_finished_runs_df(experiment_name, include_running=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> required <code>include_running</code> <code>False</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/utils/#mainsequence.tdag.distributed.utils","title":"<code>mainsequence.tdag.distributed.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/distributed/utils/#mainsequence.tdag.distributed.utils.get_request_status_from_query","title":"<code>get_request_status_from_query(query, request_url)</code>","text":"<p>:param query: :type query: :return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/instrumentation/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils","title":"<code>mainsequence.tdag.instrumentation.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils.TracerInstrumentator","title":"<code>TracerInstrumentator</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils.TracerInstrumentator.build_tracer","title":"<code>build_tracer(service_name, origin, export_trace_to_console=False)</code>","text":"<p>buidl_tracer(\"Time Series\",name) :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/","title":"Persist managers","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers","title":"<code>mainsequence.tdag.time_series.persist_managers</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager","title":"<code>DataLakePersistManager</code>","text":"<p>               Bases: <code>PersistManager</code></p> <p>A class to manage data persistence in a local data lake.</p> <p>This class handles the storage and retrieval of time series data in a local file system, organized by date ranges and table hashes.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the DataLakePersistManager with configuration from environment variables.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.set_already_run","title":"<code>set_already_run(already_run)</code>","text":"<p>This methos is critical as it control the level of introspection and avouids recursivity        This happens for example when TimeSeries.update_series_from_source(,): TimeSeries.update_series_from_source(latest_value,,**):     self.get_update_statistics() &lt;- will incurr in a circular refefence using local data late Args:     introspection:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.verify_if_already_run","title":"<code>verify_if_already_run(ts)</code>","text":"<p>This method handles all the configuration and setup necessary when running a detached local data lake :param ts: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager","title":"<code>PersistManager</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.build_update_details","title":"<code>build_update_details(source_class_name)</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.depends_on_connect","title":"<code>depends_on_connect(new_ts, is_api)</code>","text":"<p>Connects a time Serie as relationship in the DB</p> <p>Parameters:</p> Name Type Description Default <code>new_ts</code> <code>TimeSerie</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.get_pending_nodes","title":"<code>get_pending_nodes(table_id_list, filter_by_update_time)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_update_time</code> <code>bool</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.get_persisted_ts","title":"<code>get_persisted_ts()</code>","text":"<p>full Request of the persisted data should always default to DB :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.local_persist_exist_set_config","title":"<code>local_persist_exist_set_config(remote_table_hashed_name, local_configuration, remote_configuration, data_source, time_serie_source_code_git_hash, time_serie_source_code, remote_build_metadata)</code>","text":"<p>This method runs on initialization of the TimeSerie class. We also use it to retrieve the table if is already persisted :param config:</p> <p>:return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.patch_build_configuration","title":"<code>patch_build_configuration(local_configuration, remote_configuration, remote_build_metadata)</code>","text":"<p>Args:     local_configuration:     remote_configuration:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.patch_update_details","title":"<code>patch_update_details(local_hash_id=None, **kwargs)</code>","text":"<p>Patch update details ofr related_table</p> <p>Parameters:</p> Name Type Description Default <code>hash_id</code> required <code>kwargs</code> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.persist_updated_data","title":"<code>persist_updated_data(temp_df, historical_update_id, update_tracker=None, overwrite=False)</code>","text":"<p>Main update time series function, it is called from TimeSeries class</p> <p>Parameters:</p> Name Type Description Default <code>temp_df</code> <code>DataFrame</code> required <code>latest_value</code> required <code>session</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.synchronize_metadata","title":"<code>synchronize_metadata(meta_data, local_metadata, set_last_index_value=False, class_name=None)</code>","text":"<p>forces a synchronization between table and metadata :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.update_details_exist","title":"<code>update_details_exist()</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.update_source_informmation","title":"<code>update_source_informmation(git_hash_id, source_code)</code>","text":"<p>Args:     git_hash_id:     source_code:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.TimeScaleLocalPersistManager","title":"<code>TimeScaleLocalPersistManager</code>","text":"<p>               Bases: <code>PersistManager</code></p> <p>Main Controler to interacti with TimeSerie ORM</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.TimeScaleLocalPersistManager.get_full_source_data","title":"<code>get_full_source_data(remote_table_hash_id, engine='pandas')</code>","text":"<p>Returns full stored data, uses multiprocessing to achieve several queries by rows and speed :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/","title":"Time series","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series","title":"<code>mainsequence.tdag.time_series.time_series</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie","title":"<code>APITimeSerie</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.__init__","title":"<code>__init__(data_source_id, local_hash_id, data_source_local_lake=None)</code>","text":"<p>A time serie is uniquely identified in tdag by  data_source_id and table_name :param data_source_id: :param table_name:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.build_from_unique_identifier","title":"<code>build_from_unique_identifier(unique_identifier)</code>  <code>classmethod</code>","text":"<p>:param vam_source_name: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(asset_ranges_map)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_ranges</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.get_update_statistics","title":"<code>get_update_statistics(asset_symbols=None)</code>","text":"<p>getts latest value directly from querying the DB, args and kwargs are nedeed for datalake</p> <p>Parameters:</p> Name Type Description Default <code>args</code> required <code>kwargs</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.persist_data_to_local_lake","title":"<code>persist_data_to_local_lake(temp_df, update_tracker, latest_value, overwrite=False)</code>","text":"<p>Helper series to  persist data to a local lake for reading purposes :param temp_df: :param update_tracker: :param latest_value: :param overwrite: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer","title":"<code>ConfigSerializer</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.deserialize_pickle_state","title":"<code>deserialize_pickle_state(state, include_vam_client_objects, data_source_id, graph_depth_limit, graph_depth, local_metadatas, ignore_pydantic=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> required <code>deserialize_pickle_state</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_config","title":"<code>rebuild_config(config, ignore_pydantic=False)</code>  <code>classmethod</code>","text":"<p>:param config: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_pydantic_model","title":"<code>rebuild_pydantic_model(details, state_kwargs=None)</code>  <code>classmethod</code>","text":"<p>If there is an state rebuild the configuration then the method to rebuild related objects is from state Args:     details:      state_kwargs: </p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_serialized_config","title":"<code>rebuild_serialized_config(config, time_serie_class_name)</code>  <code>classmethod</code>","text":"<p>rebulds configuration from config file, particularly Assets :param config:</p> <p>:param time_serie_class_name: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_serialized_wrapper_dict","title":"<code>rebuild_serialized_wrapper_dict(time_series_dict_config)</code>  <code>classmethod</code>","text":"<p>rebuilds configuration from time_series Wrapper :param time_series_dict_config:</p> <p>:return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.serialize_init_kwargs","title":"<code>serialize_init_kwargs(kwargs)</code>","text":"<p>serializes  TimeSeries init_kwargs to be able to  persist in local configuration :param kwargs: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods","title":"<code>DataPersistanceMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(asset_ranges_map)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_ranges</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.flush_local_persisted","title":"<code>flush_local_persisted(flush_only_time_series=True, session=None)</code>","text":"<p>deletes  persisted data :param flush_sub_folders: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_last_observation","title":"<code>get_last_observation(asset_symbols=None)</code>","text":"<p>(1) Requests last observatiion from local persist manager (3) evaluates if last observation is consistent</p> <p>Parameters:</p> Name Type Description Default <code>asset_symbols</code> <code>Union[None, list]</code> <code>None</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_latest_update_by_assets_filter","title":"<code>get_latest_update_by_assets_filter(asset_symbols, last_update_per_asset)</code>","text":"<p>Gets the latest update from a symbol list :param asset_symbols: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_update_statistics","title":"<code>get_update_statistics(asset_symbols=None)</code>","text":"<p>getts latest value directly from querying the DB, args and kwargs are nedeed for datalake</p> <p>Parameters:</p> Name Type Description Default <code>args</code> required <code>kwargs</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.update_details_in_dependecy_tree","title":"<code>update_details_in_dependecy_tree(set_relation_tree=True, include_head=False, *args, **kwargs)</code>","text":"<p>updates schedule from all tree related time series :param schedule: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.upsert_data","title":"<code>upsert_data(data_df)</code>","text":"<p>Updates and Insert data into DB :param data_df: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods","title":"<code>GraphNodeMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.get_all_local_dependencies","title":"<code>get_all_local_dependencies()</code>","text":"<p>get relation tree by ids in the graph :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.get_update_map","title":"<code>get_update_map(dependecy_map=None)</code>","text":"<p>Obtain all local time_series in the dependency graph by introspecting the code :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.set_relation_tree","title":"<code>set_relation_tree()</code>","text":"<p>Sets relationhsip in the DB :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ModelList","title":"<code>ModelList</code>","text":"<p>               Bases: <code>list</code></p> <p>Necessary for configuration</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie","title":"<code>TimeSerie</code>","text":"<p>               Bases: <code>DataPersistanceMethods</code>, <code>GraphNodeMethods</code>, <code>TimeSerieRebuildMethods</code></p> <p>Pipeline</p> <pre><code>-__init__\n- _create_config\n\n- _init_db_properties_config\n- set_graph node\n</code></pre>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.hash_id","title":"<code>hash_id</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.__init__","title":"<code>__init__(init_meta=None, build_meta_data=None, local_kwargs_to_ignore=None, *args, **kwargs)</code>","text":"<p>Initializes the TimeSerie object with the provided metadata and configurations.</p> <p>This method sets up the time series object, loading the necessary configurations and metadata. If <code>is_local_relation_tree_set</code> is True, it avoids recalculating the relationship tree in schedulers, optimizing the process if the tree is already calculated during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>init_meta</code> <code>dict</code> <p>Metadata for initializing the time series instance.</p> <code>None</code> <code>build_meta_data</code> <code>dict</code> <p>Metadata related to the building process of the time series.</p> <code>None</code> <code>local_kwargs_to_ignore</code> <code>list</code> <p>List of keyword arguments to ignore during configuration.</p> <code>None</code> <code>*args</code> <code>tuple</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.get_html_description","title":"<code>get_html_description()</code>","text":"<p>must return a descript on html tags so it can be readable and rendedered Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.get_time_serie_source_code_git_hash","title":"<code>get_time_serie_source_code_git_hash(TimeSerieClass)</code>  <code>staticmethod</code>","text":"<p>Hashes a time serie source code</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.patch_build_configuration","title":"<code>patch_build_configuration()</code>","text":"<p>This method comes in handy when there is a change in VAM models extra configuration. This method will properly update the models on all the tree</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.pre_update_setting_routines","title":"<code>pre_update_setting_routines(scheduler, set_time_serie_queue_status, update_tree, metadata=None, local_metadata=None)</code>","text":"<p>Routines to execute previous to an update</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.run","title":"<code>run(debug_mode, *, update_tree=True, force_update=False, update_only_tree=False, remote_scheduler=None)</code>","text":"<p>Args:     debug_mode:     update_tree:     force_update:     update_only_tree:     remote_scheduler:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.set_data_source","title":"<code>set_data_source(data_source=None)</code>","text":"<p>:return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.set_dependencies_df","title":"<code>set_dependencies_df()</code>","text":"<p>:return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.update_series_from_source","title":"<code>update_series_from_source(latest_value, *args, **kwargs)</code>","text":"<p>This method performs all the necessary logic to update our time series. The method should always return a DataFrame with the following characteristics:</p> <p>1) A unidimensional index where the index is of the type <code>DatetimeIndex</code> and the dates are in <code>pytz.utc</code>. 2) A multidimensional index that should always have 3 dimensions: <code>time_index</code> (with the same characteristics as before), <code>asset_symbol</code>, and <code>execution_venue_symbol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>latest_value</code> <code>Union[None, datetime]</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieConfigKwargs","title":"<code>TimeSerieConfigKwargs</code>","text":"<p>               Bases: <code>dict</code></p> <p>Necessary class for configuration</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods","title":"<code>TimeSerieRebuildMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.persist_to_pickle","title":"<code>persist_to_pickle(overwrite=False)</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.rebuild_and_set_from_local_hash_id","title":"<code>rebuild_and_set_from_local_hash_id(local_hash_id, data_source_id, set_dependencies_df=False, graph_depth_limit=1)</code>  <code>classmethod</code>","text":"<p>:param local_hash_id: :param data_source_id: :param set_dependencies_df: :param graph_depth_limit: :param local_metadatas: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.rebuild_from_configuration","title":"<code>rebuild_from_configuration(local_hash_id, data_source)</code>  <code>classmethod</code>","text":"<p>:param serie_data_folder:</p> <p>:return: TimeSerie</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.run_in_debug_scheduler","title":"<code>run_in_debug_scheduler(break_after_one_update=True, run_head_in_main_process=True, wait_for_update=True, force_update=True, debug=True, update_tree=True, raise_exception_on_error=True)</code>","text":"<p>Args:     break_after_one_update:     run_head_in_main_process:     wait_for_update:     force_update:     debug:     update_tree:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.set_state_with_sessions","title":"<code>set_state_with_sessions(include_vam_client_objects=True, graph_depth_limit=1000, local_metadatas=None, graph_depth=0)</code>","text":"<p>Method to set state after it was loaded from pickle.</p> <p>Parameters:</p> Name Type Description Default <code>include_vam_client_objects</code> <code>True</code> <code>graph_depth_limit</code> <code>1000</code> <code>metadatas</code> <code>pre-requestd dictionary of metadatas to speed calculation of rebuild of state</code> required <code>graph_depth</code> <code>0</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.update","title":"<code>update(update_tracker, debug_mode, raise_exceptions=True, update_tree=False, metadatas=None, update_only_tree=False, force_update=False, use_state_for_update=False)</code>","text":"<p>Main update method for time series that interacts with Graph node. Time series should be updated through this method only :param update_tree_kwargs: :param raise_exceptions: :param update_tree: :param scheduler: models.Scheduler :param metadatas: pre-requested metadatas to speed initiation of ts :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie","title":"<code>WrapperTimeSerie</code>","text":"<p>               Bases: <code>TimeSerie</code></p> <p>A wrapper class for managing multiple TimeSerie objects.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.wrapped_latest_index_value","title":"<code>wrapped_latest_index_value: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the latest values of all wrapped TimeSeries.</p> <p>Returns:     A dictionary with keys corresponding to TimeSerie keys and values being their latest values.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.wrapper_keys","title":"<code>wrapper_keys: List[str]</code>  <code>property</code>","text":"<p>Get the keys of all wrapped TimeSeries.</p> <p>Returns:     A list of keys for all wrapped TimeSeries.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.__init__","title":"<code>__init__(time_series_dict, *args, **kwargs)</code>","text":"<p>Initialize the WrapperTimeSerie.</p> <p>Args:     time_series_dict: Dictionary of TimeSerie objects.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore instance attributes from a pickled state.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.children_is_updating","title":"<code>children_is_updating()</code>","text":"<p>Check if any wrapped TimeSerie is currently updating.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_pandas_df_list_data_greater_than","title":"<code>get_pandas_df_list_data_greater_than(target_value, great_or_equal, thread=True)</code>","text":"<p>Get DataFrames from all wrapped TimeSeries greater than a target value.</p> <p>Args:     target_value: The target datetime value to compare against.     great_or_equal: Whether to include the target value (True) or not (False).     thread: Whether to use threading for parallel processing.</p> <p>Returns:     A dictionary with TimeSerie keys and their corresponding DataFrames or error messages.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_ts_as_pandas","title":"<code>get_ts_as_pandas()</code>","text":"<p>Get all wrapped TimeSeries as a list of pandas DataFrames.</p> <p>Returns:     A list of pandas DataFrames, one for each wrapped TimeSerie.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_wrapped","title":"<code>get_wrapped()</code>","text":"<p>Get all wrapped TimeSeries, including nested ones.</p> <p>Returns:     A list of all wrapped TimeSerie objects, including those nested in other WrapperTimeSeries.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.items","title":"<code>items()</code>","text":"<p>Get items of wrapped TimeSeries.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.pandas_df_concat_on_rows_by_key_between_dates","title":"<code>pandas_df_concat_on_rows_by_key_between_dates(start_date, great_or_equal, end_date, less_or_equal, thread=False, asset_symbols=None, return_as_list=False, key_date_filter=None)</code>","text":"<p>Concatenate DataFrames from all wrapped TimeSeries between given dates.</p> <p>Args:     start_date: The start date for the data range.     great_or_equal: Whether to include the start date (True) or not (False).     end_date: The end date for the data range.     less_or_equal: Whether to include the end date (True) or not (False).     thread: Whether to use threading for parallel processing.     asset_symbols: asset_symbol filter     return_as_list: If True, return a dictionary of DataFrames instead of concatenating.    key_date_filter: Concatenate DataFrames only for key date filter. Returns:     A concatenated DataFrame or a dictionary of DataFrames if return_as_list is True.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.pandas_df_concat_on_rows_by_key_greater_than","title":"<code>pandas_df_concat_on_rows_by_key_greater_than(target_value, great_or_equal, thread=False, return_as_list=False, columns=None, *args, **kwargs)</code>","text":"<p>Concatenate DataFrames from all wrapped TimeSeries greater than a target value.</p> <p>Args:     target_value: The latest datetime value to compare against.     great_or_equal: Whether to include the target value (True) or not (False).     thread: Whether to use threading for parallel processing.     return_as_list: If True, return a dictionary of DataFrames instead of concatenating.     columns: Optional list of columns to include.</p> <p>Returns:     A concatenated DataFrame or a dictionary of DataFrames if return_as_list is True.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.set_local_persist_manager_if_not_set","title":"<code>set_local_persist_manager_if_not_set()</code>","text":"<p>Set local persist manager for all wrapped TimeSeries.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.set_state_with_sessions","title":"<code>set_state_with_sessions(include_vam_client_objects, graph_depth_limit, graph_depth, local_metadatas=None)</code>","text":"<p>Set state with sessions for all wrapped TimeSeries.</p> <p>Args:     include_vam_client_objects: Whether to include asset ORM objects.     graph_depth_limit: The maximum depth of the graph to traverse.     graph_depth: The current depth in the graph.     local_metadatas: Optional metadata dictionary.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.update_series_from_source","title":"<code>update_series_from_source(latest_value, *args, **kwargs)</code>","text":"<p>Implemented in the wrapped nodes</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.values","title":"<code>values()</code>","text":"<p>Get values of wrapped TimeSeries.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.hash_signature","title":"<code>hash_signature(dictionary)</code>","text":"<p>MD5 hash of a dictionary used to hash the local annd remote configuration of tables :param dictionary: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/utils/#mainsequence.tdag.time_series.utils","title":"<code>mainsequence.tdag.time_series.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/api/","title":"Api","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/api/#mainsequence.tdag.time_series.update.api","title":"<code>mainsequence.tdag.time_series.update.api</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/ray_manager/","title":"Ray manager","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager","title":"<code>mainsequence.tdag.time_series.update.ray_manager</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager.RayUpdateManager","title":"<code>RayUpdateManager</code>","text":"<p>Controller for interactions with ray cluster</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager.RayUpdateManager.get_results_from_futures_list","title":"<code>get_results_from_futures_list(futures)</code>","text":"<p>should be a list of futures objects ray.remote() Args:     futures ():</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/","title":"Scheduler","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler","title":"<code>mainsequence.tdag.time_series.update.scheduler</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.SchedulerUpdater","title":"<code>SchedulerUpdater</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.SchedulerUpdater.start","title":"<code>start(debug=False, update_tree=True, break_after_one_update=False, raise_exception_on_error=False, update_extra_kwargs=None, run_head_in_main_process=False, force_update=False, sequential_update=False, update_only_tree=False, api_port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If True, all dependencies of a time series run in the same process. Defaults to False.</p> <code>False</code> <code>update_tree</code> <code>bool or dict</code> <p>If True, updates the tree of dependent tasks.</p> <code>True</code> <code>break_after_one_update</code> <code>bool</code> <p>If True, the process stops after the first update cycle. Defaults to False.</p> <code>False</code> <code>raise_exception_on_error</code> <code>bool</code> <p>If True, raises an exception on encountering an error during execution. Otherwise, errors are handled silently. Defaults to False.</p> <code>False</code> <code>update_extra_kwargs</code> <code>dict or None</code> <p>Additional parameters (if any) to pass along when updating. Defaults to None.</p> <code>None</code> <code>run_head_in_main_process</code> <code>bool</code> <p>If True, each \"head\" time series is run in the main scheduler process. Useful for debugging. Defaults to False.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>If True, forces an update run even if it's not required. Defaults to False.</p> <code>False</code> <code>sequential_update</code> <code>bool</code> <p>If True, runs each \"head\" time series one by one instead of in parallel. Defaults to False.</p> <code>False</code> <code>update_only_tree</code> <code>bool</code> <p>If True, only the dependency tree is updated without fully processing every step. Defaults to False.</p> <code>False</code> <code>api_port</code> <code>int or None</code> <p>The port on which any exposed APIs should run. If None, no API is exposed. Defaults to None.</p> <code>None</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor","title":"<code>TimeSerieHeadUpdateActor</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor.__init__","title":"<code>__init__(local_hash_id, data_source_id, scheduler, debug, update_tree, update_extra_kwargs, remote_table_hashed_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hash_id</code> required <code>scheduler</code> <code>Scheduler</code> required <code>debug</code> required <code>update_tree</code> required <code>update_extra_kwargs</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor.run_one_step_update","title":"<code>run_one_step_update(force_update=False, update_only_tree=False)</code>","text":"<p>Main update Method for a time serie Head</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.set_data_source","title":"<code>set_data_source(pod_source=None, tdag_detached=False, override_all=False)</code>","text":"<p>:param override_all: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/update_methods/","title":"Update methods","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods","title":"<code>mainsequence.tdag.time_series.update.update_methods</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.TimeSerieUpdater","title":"<code>TimeSerieUpdater</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.update_remote_from_hash_id","title":"<code>update_remote_from_hash_id(*args, **kwargs)</code>","text":"<p>Ray wrapper for session update :param args: :param kwargs: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.update_remote_from_hash_id_local","title":"<code>update_remote_from_hash_id_local(telemetry_carrier, scheduler_uid, local_hash_id, data_source_id)</code>","text":"<p>Args:     in_update_tree_node_uid ():     update_tree_kwargs ():     execution_start ():     telemtry_carrier ():     update_priority ():     hash_id ():</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils","title":"<code>mainsequence.tdag.time_series.update.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.UpdateInterface","title":"<code>UpdateInterface</code>","text":"<p>Helper class to avoid calling ray in other modules</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.get_available_port","title":"<code>get_available_port(port_range=(8000, 8090))</code>","text":"<p>Check if the given port is free, and if not, find an available port within the range.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.is_port_free","title":"<code>is_port_free(port)</code>","text":"<p>Check if the port is free on the local machine.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/","title":"Models","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models","title":"<code>mainsequence.tdag_client.models</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers","title":"<code>DynamicTableHelpers</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.copy_table_data_to_other_orm","title":"<code>copy_table_data_to_other_orm(target_database_uri, target_admin_user, target_admin_password, target_orm_url_api_root, target_gcp_credentials_path, hash_id_contains, source_database_uri, source_orm_url_api_root, source_orm_admin_user, source_orm_admin_password, source_gcp_credentials_path, start_date, end_date, great_or_equal, less_or_equal, overwrite=False, copy_descendants=False, exclude_hash_ids=None)</code>","text":"<p>This function copies table data from an ORM to another one example: copy_database</p> <p>Parameters:</p> Name Type Description Default <code>target_database_uri</code> <code>str</code> required <code>target_admin_user</code> <code>str</code> required <code>target_admin_password</code> <code>str</code> required <code>target_orm_url_api_root</code> <code>str</code> required <code>hash_id_contains</code> <code>str</code> required <code>start_date</code> <code>datetime</code> required <code>end_date</code> <code>datetime</code> required <code>great_or_equal</code> <code>bool</code> required <code>less_or_equal</code> <code>bool</code> required <code>overwrite</code> <code>False</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.create","title":"<code>create(metadata_kwargs)</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.get_update_statistics","title":"<code>get_update_statistics(hash_id)</code>","text":"<p>Gets latest value from Hash_id :param hash_id: :type hash_id: :return: :rtype:i</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.patch","title":"<code>patch(metadata, timeout=None, *args, **kwargs)</code>","text":"<p>Main patch method :return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.set_compression_policy","title":"<code>set_compression_policy(metadata, interval)</code>","text":"<p>:param hash_id: :type hash_id: :return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.time_serie_exist_in_db","title":"<code>time_serie_exist_in_db(hash_id)</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.upsert_data_into_table","title":"<code>upsert_data_into_table(metadata, local_metadata, historical_update_id, data, overwrite, data_source, logger=logger)</code>","text":"<p>1) Build or get metadata 2) build table configuration relationships</p> <p>Parameters:</p> Name Type Description Default <code>build_meta_data</code> required <code>build_configuration</code> required <code>data</code> <code>DataFrame</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.Scheduler","title":"<code>Scheduler</code>","text":"<p>               Bases: <code>BaseTdagPydanticModel</code>, <code>BaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.Scheduler.stop_heart_beat","title":"<code>stop_heart_beat()</code>","text":"<p>Stop the heartbeat gracefully.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerie","title":"<code>TimeSerie</code>","text":"<p>               Bases: <code>BaseObject</code></p> <p>Main Methods of a standard time serie by hash_id</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate","title":"<code>TimeSerieLocalUpdate</code>","text":"<p>               Bases: <code>BaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.create_historical_update","title":"<code>create_historical_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:param args: :type args: :param kwargs: :type kwargs: :return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.get_mermaid_dependency_diagram","title":"<code>get_mermaid_dependency_diagram(local_hash_id, data_source_id, desc=True, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param local_hash_id: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.post_data_frame_in_chunks","title":"<code>post_data_frame_in_chunks(serialized_data_frame, logger, chunk_size=50000, local_metadata=None, data_source=None, index_names=None, time_index_name='timestamp', overwrite=False, JSON_COMPRESSED_PREFIX='base64-gzip', session=None)</code>  <code>classmethod</code>","text":"<p>Sends a large DataFrame to a Django backend in multiple chunks.</p> <p>:param serialized_data_frame: The DataFrame to upload. :param url: The endpoint URL (e.g. https://yourapi.com/upload-chunk/). :param chunk_size: Number of rows per chunk. :param local_metadata: General metadata dict you want to send with each chunk. :param data_source: Additional info about the source of the data. :param index_names: Index columns in the DataFrame. :param time_index_name: The column name used for time indexing. :param overwrite: Boolean indicating whether existing data should be overwritten. :param JSON_COMPRESSED_PREFIX: String indicating the compression scheme in your JSON payload. :param session: Optional requests.Session() for connection reuse.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode","title":"<code>TimeSerieNode</code>","text":"<p>               Bases: <code>BaseTdagPydanticModel</code>, <code>BaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.depends_on_connect","title":"<code>depends_on_connect(target_class_name, source_local_hash_id, target_local_hash_id, source_data_source_id, target_data_source_id, target_human_readable)</code>  <code>classmethod</code>","text":"<p>Connects and build relationship</p> <p>Parameters:</p> Name Type Description Default <code>source_hash_id</code> required <code>target_hash_id</code> required <code>target_class_name</code> <code>str</code> required <code>target_human_readable</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.depends_on_connect_remote_table","title":"<code>depends_on_connect_remote_table(source_hash_id, source_local_hash_id, source_data_source_id, target_data_source_id, target_local_hash_id)</code>  <code>classmethod</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.patch_build_configuration","title":"<code>patch_build_configuration(remote_table_patch, build_meta_data, data_source_id, local_table_patch)</code>  <code>classmethod</code>","text":"<p>Args:     remote_table_patch:     local_table_patch:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/models/#mainsequence.tdag_client.models.none_if_backend_detached","title":"<code>none_if_backend_detached(func)</code>","text":"<p>Decorator that evaluates BACKEND_DETACHED before executing the function. If BACKEND_DETACHED() returns True, the function is skipped, and None is returned. Otherwise, the function is executed as normal.</p> <p>It supports regular functions, property methods, classmethods, and staticmethods.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/#mainsequence.tdag_client.utils","title":"<code>mainsequence.tdag_client.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/#mainsequence.tdag_client.utils.LazyConstants","title":"<code>LazyConstants</code>","text":"<p>               Bases: <code>dict</code></p> <p>Class Method to load constants only once they are called. this minimizes the calls to the API</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/#mainsequence.tdag_client.utils.chunks","title":"<code>chunks(lst, n)</code>","text":"<p>Yield successive n-sized chunks from lst.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/#mainsequence.tdag_client.utils.inflate_json_compresed_column","title":"<code>inflate_json_compresed_column(compressed_series)</code>","text":"<p>Inflates a compressed json_compressed series</p> <p>Parameters:</p> Name Type Description Default <code>compressed_series</code> <code>Series</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/utils/#mainsequence.tdag_client.utils.is_process_running","title":"<code>is_process_running(pid)</code>","text":"<p>Check if a process with the given PID is running.</p> <p>Args:     pid (int): The process ID to check.</p> <p>Returns:     bool: True if the process is running, False otherwise.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/","title":"Local data lake","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake","title":"<code>mainsequence.tdag_client.data_sources_interfaces.local_data_lake</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface","title":"<code>DataLakeInterface</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.build_time_and_symbol_filter","title":"<code>build_time_and_symbol_filter(start_date=None, great_or_equal=True, less_or_equal=True, end_date=None, asset_symbols=None)</code>  <code>staticmethod</code>","text":"<p>Build hashable parquet filters based on the parameters.</p> <p>Args:     metadata (dict): Metadata dictionary, not used for filtering here but included for extensibility.     start_date (datetime.datetime, optional): Start date for filtering.     great_or_equal (bool): Whether the start date condition is <code>&gt;=</code> or <code>&gt;</code>.     less_or_equal (bool): Whether the end date condition is <code>&lt;=</code> or <code>&lt;</code>.     end_date (datetime.datetime, optional): End date for filtering.     asset_symbols (list, optional): List of asset symbols to filter on.</p> <p>Returns:     tuple: Hashable parquet filters for use with pandas or pyarrow.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(table_name, asset_ranges_map)</code>","text":"<p>:param table_name: :param asset_ranges_map: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.persist_datalake","title":"<code>persist_datalake(data, overwrite, table_name, time_index_name, index_names)</code>","text":"<p>Partition per week , do not partition per asset_symbol as system only allows 1024 partittions Args:     data:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.query_datalake","title":"<code>query_datalake(table_name, filters=None)</code>","text":"<p>Queries the data lake for time series data.</p> <p>If the table_hash is in nodes_to_persist, it retrieves or creates the data. Otherwise, it updates the series from the source.</p> <p>Args:     ts: The time series object.     latest_value: The latest timestamp to query from.     symbol_list: List of symbols to retrieve data for.     great_or_equal: Boolean flag for date comparison.     update_tree_kwargs: Dictionary of kwargs for updating the tree.</p> <p>Returns:     pd.DataFrame: The queried data.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.memory_usage_exceeds_limit","title":"<code>memory_usage_exceeds_limit(max_usage_percentage)</code>","text":"<p>Checks if the current memory usage exceeds the given percentage of total memory.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.read_full_data","title":"<code>read_full_data(file_path, filters=None, use_s3_if_available=False, max_memory_usage=80)</code>  <code>cached</code>","text":"<p>Cached access to static datalake file</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/","title":"Timescale","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale","title":"<code>mainsequence.tdag_client.data_sources_interfaces.timescale</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.direct_data_from_db","title":"<code>direct_data_from_db(metadata, connection_uri, start_date=None, great_or_equal=True, less_or_equal=True, end_date=None, columns=None, asset_symbols=None)</code>","text":"<p>Connects directly to the DB without passing through the ORM to speed up calculations.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>Metadata containing table and column details.</p> required <code>connection_config</code> <code>dict</code> <p>Connection configuration for the database.</p> required <code>start_date</code> <code>datetime</code> <p>The start date for filtering. If None, no lower bound is applied.</p> <code>None</code> <code>great_or_equal</code> <code>bool</code> <p>Whether the start_date filter is inclusive (&gt;=). Defaults to True.</p> <code>True</code> <code>less_or_equal</code> <code>bool</code> <p>Whether the end_date filter is inclusive (&lt;=). Defaults to True.</p> <code>True</code> <code>end_date</code> <code>datetime</code> <p>The end date for filtering. If None, no upper bound is applied.</p> <code>None</code> <code>columns</code> <code>list</code> <p>Specific columns to select. If None, all columns are selected.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Data from the table as a pandas DataFrame, optionally filtered by date range.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.direct_table_update","title":"<code>direct_table_update(table_name, serialized_data_frame, overwrite, grouped_dates, time_index_name, index_names, table_is_empty, table_index_names, time_series_orm_db_connection=None, use_chunks=True, num_threads=4)</code>","text":"<p>Updates the database table with the given DataFrame.</p> <p>Parameters: - table_name: Name of the database table. - serialized_data_frame: DataFrame containing the data to insert. - overwrite: If True, existing data in the date range will be deleted before insertion. - time_index_name: Name of the time index column. - index_names: List of index column names. - table_is_empty: If True, the table is empty. - time_series_orm_db_connection: Database connection string. - use_chunks: If True, data will be inserted in chunks using threads. - num_threads: Number of threads to use when use_chunks is True.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(table_name, asset_ranges_map, index_names, data_source, column_types)</code>","text":"<p>Query time series data dynamically based on asset ranges.</p> <p>Args:     table_name (str): The name of the table to query.     asset_ranges_map (dict): A dictionary where keys are asset symbols and values are dictionaries containing:                              - 'start_date' (datetime): The start date of the range.                              - 'start_date_operand' (str): The SQL operand for the start date (e.g., '&gt;=' or '&gt;').                              - 'end_date' (datetime or None): The end date of the range.     index_names (list): List of column names to set as the DataFrame index.     data_source: A data source object with a method <code>get_connection_uri()</code> to get the database connection URI.</p> <p>Returns:     pd.DataFrame: A Pandas DataFrame with the queried data, indexed by the specified columns.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.process_and_update_table","title":"<code>process_and_update_table(serialized_data_frame, metadata, grouped_dates, data_source, index_names, time_index_name, logger, overwrite=False, JSON_COMPRESSED_PREFIX=None)</code>","text":"<p>Process a serialized DataFrame, handle overwriting, and update a database table.</p> <p>Args:     serialized_data_frame (pd.DataFrame): The DataFrame to process and update.     metadata (dict): Metadata about the table, including table configuration.     grouped_dates (list): List of grouped dates to assist with the update.     data_source (object): A data source object with a <code>get_connection_uri</code> method.     index_names (list): List of index column names.     time_index_name (str): The name of the time index column.     overwrite (bool): Whether to overwrite the table or not.     JSON_COMPRESSED_PREFIX (list): List of prefixes to identify JSON-compressed columns.</p> <p>Returns:     None</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/","title":"Local vault","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault","title":"<code>mainsequence.vam_client.local_vault</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.decrypt_secrets","title":"<code>decrypt_secrets(encrypted_secrets)</code>","text":"<p>Decrypt the secrets JSON.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.encrypt_secrets","title":"<code>encrypt_secrets(secrets)</code>","text":"<p>Encrypt the secrets JSON.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.generate_key","title":"<code>generate_key()</code>","text":"<p>Generate an encryption key and save it to a file.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.get_all_entries_in_vault_for_venue","title":"<code>get_all_entries_in_vault_for_venue(execution_venue_symbol)</code>","text":"<p>Retrieve all entries from the database for a specific execution venue.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.get_secrets_for_account_id","title":"<code>get_secrets_for_account_id(account_id)</code>","text":"<p>Gets the secrets from the vault from an specific account_id</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.load_key","title":"<code>load_key()</code>","text":"<p>Load the encryption key from the file.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.validate_secrets","title":"<code>validate_secrets(secrets, execution_venue_symbol)</code>","text":"<p>Validate that secrets conform to the schema for the given execution venue.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/","title":"Models","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models","title":"<code>mainsequence.vam_client.models</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.AccountMixin","title":"<code>AccountMixin</code>","text":"<p>               Bases: <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.AccountMixin.build_rebalance","title":"<code>build_rebalance(latest_holdings, tolerance, change_cash_asset_to_currency_asset=None)</code>","text":"<p>:param latest_holdings: :type latest_holdings: :param tolerance: :type tolerance: :param change_cash_asset_to_currency_asset: :type change_cash_asset_to_currency_asset: :return:</p> <p>rebalance[] = {\"rebalance\":{\"quantity\":, \"reference_price\":, \"reference_notional\":}, \"asset\":Asset} <p>:rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin","title":"<code>AssetMixin</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin.batch_upsert","title":"<code>batch_upsert(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin.get_ccxt_symbol","title":"<code>get_ccxt_symbol(settlement_symbol=None)</code>","text":"<p>Gets the right symbol for ccxt</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm","title":"<code>BaseObjectOrm</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.create","title":"<code>create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.patch_by_id","title":"<code>patch_by_id(instance_id, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.update_or_create","title":"<code>update_or_create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPositions","title":"<code>ExecutionPositions</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPositions.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_signal_hash_id, positions_list, positions_time, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPrediction","title":"<code>ExecutionPrediction</code>","text":"<p>               Bases: <code>BaseObjectOrm</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPrediction.add_prediction_from_time_serie","title":"<code>add_prediction_from_time_serie(time_serie_hash_id, prediction_time, symbol_to_search_map, predictions, human_readable_name=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.HistoricalWeights","title":"<code>HistoricalWeights</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.HistoricalWeights.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_hash_id, positions_list, weights_date, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails","title":"<code>TargetPortfolioFrontEndDetails</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails.create","title":"<code>create(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails.create_or_update","title":"<code>create_or_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund","title":"<code>VirtualFund</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund.build_rebalance_from_target_weights","title":"<code>build_rebalance_from_target_weights(target_execution_postitions, positions_prices, absolute_rebalance_weight_limit=0.02)</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund.sanitize_target_weights_for_execution_venue","title":"<code>sanitize_target_weights_for_execution_venue(target_weights)</code>","text":"<p>This functions switches assets from main net to test net to guarante consistency in the recording of trades and orders Args:     target_weights:{asset_id:WeightExecutionPosition}</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_alpaca/","title":"Models alpaca","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca","title":"<code>mainsequence.vam_client.models_alpaca</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.AlpacaAccount","title":"<code>AlpacaAccount</code>","text":"<p>               Bases: <code>AccountMixin</code>, <code>AlpacaBaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.AlpacaAccount.sync_funds","title":"<code>sync_funds(target_trade_time=None, target_holdings=None, holdings_source=None, target_weights=None, end_of_execution_time=None, timeout=None, is_trade_snapshot=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>account_data</code> required <code>target_trade_time</code> <code>Union[None, datetime]</code> <code>None</code> <code>target_holdings</code> <code>Union[None, dict]</code> <code>None</code> <code>holdings_source</code> <code>Union[str, None]</code> <code>None</code> <code>end_of_execution_time</code> <code>Union[None, datetime]</code> <code>None</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.build_alpaca_account_from_keys","title":"<code>build_alpaca_account_from_keys(execution_venue, api_key, api_secret, account_id)</code>","text":"<p>Args:     execution_venue:     api_key:     api_secret:</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/","title":"Models binance","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/#mainsequence.vam_client.models_binance","title":"<code>mainsequence.vam_client.models_binance</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BaseFuturesAccount","title":"<code>BaseFuturesAccount</code>","text":"<p>               Bases: <code>AccountMixin</code>, <code>BinanceBaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BaseFuturesAccount.sync_funds","title":"<code>sync_funds(target_trade_time=None, target_holdings=None, holdings_source=None, target_weights=None, end_of_execution_time=None, timeout=None, is_trade_snapshot=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>account_data</code> required <code>target_trade_time</code> <code>Union[None, datetime]</code> <code>None</code> <code>target_holdings</code> <code>Union[None, dict]</code> <code>None</code> <code>holdings_source</code> <code>Union[str, None]</code> <code>None</code> <code>end_of_execution_time</code> <code>Union[None, datetime]</code> <code>None</code>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BinanceAssetFutureUSDM","title":"<code>BinanceAssetFutureUSDM</code>","text":"<p>               Bases: <code>FutureUSDMMixin</code>, <code>BinanceBaseObject</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BinanceAssetFutureUSDM.batch_upsert_from_base_quote","title":"<code>batch_upsert_from_base_quote(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/","title":"Models helpers","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers","title":"<code>mainsequence.vam_client.models_helpers</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AccountMixin","title":"<code>AccountMixin</code>","text":"<p>               Bases: <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AccountMixin.build_rebalance","title":"<code>build_rebalance(latest_holdings, tolerance, change_cash_asset_to_currency_asset=None)</code>","text":"<p>:param latest_holdings: :type latest_holdings: :param tolerance: :type tolerance: :param change_cash_asset_to_currency_asset: :type change_cash_asset_to_currency_asset: :return:</p> <p>rebalance[] = {\"rebalance\":{\"quantity\":, \"reference_price\":, \"reference_notional\":}, \"asset\":Asset} <p>:rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin","title":"<code>AssetMixin</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin.batch_upsert","title":"<code>batch_upsert(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin.get_ccxt_symbol","title":"<code>get_ccxt_symbol(settlement_symbol=None)</code>","text":"<p>Gets the right symbol for ccxt</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm","title":"<code>BaseObjectOrm</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.create","title":"<code>create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.patch_by_id","title":"<code>patch_by_id(instance_id, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.update_or_create","title":"<code>update_or_create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPositions","title":"<code>ExecutionPositions</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPositions.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_signal_hash_id, positions_list, positions_time, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPrediction","title":"<code>ExecutionPrediction</code>","text":"<p>               Bases: <code>BaseObjectOrm</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPrediction.add_prediction_from_time_serie","title":"<code>add_prediction_from_time_serie(time_serie_hash_id, prediction_time, symbol_to_search_map, predictions, human_readable_name=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.HistoricalWeights","title":"<code>HistoricalWeights</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.HistoricalWeights.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_hash_id, positions_list, weights_date, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails","title":"<code>TargetPortfolioFrontEndDetails</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails.create","title":"<code>create(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails.create_or_update","title":"<code>create_or_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund","title":"<code>VirtualFund</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund.build_rebalance_from_target_weights","title":"<code>build_rebalance_from_target_weights(target_execution_postitions, positions_prices, absolute_rebalance_weight_limit=0.02)</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund.sanitize_target_weights_for_execution_venue","title":"<code>sanitize_target_weights_for_execution_venue(target_weights)</code>","text":"<p>This functions switches assets from main net to test net to guarante consistency in the recording of trades and orders Args:     target_weights:{asset_id:WeightExecutionPosition}</p> <p>Returns:</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.get_model_class","title":"<code>get_model_class(model_class)</code>","text":"<p>Reverse look from model class by name</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>str</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.sync_account_funds","title":"<code>sync_account_funds(account, *args, **kwargs)</code>","text":"<p>This functions takes and Account and makes the correct sync  by quering the right account objectt</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>Account</code> required"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/","title":"Utils","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/#mainsequence.vam_client.utils","title":"<code>mainsequence.vam_client.utils</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/#mainsequence.vam_client.utils.LazyConstants","title":"<code>LazyConstants</code>","text":"<p>               Bases: <code>dict</code></p> <p>Class Method to load constants only once they are called. this minimizes the calls to the API</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/#mainsequence.vam_client.utils.LazyConstants.to_attr_dict","title":"<code>to_attr_dict(data)</code>","text":"<p>Recursively convert a Python dict into an object that allows dot-notation access. Non-dict values (e.g., int, str, list) are returned as-is; dicts become _AttrDict.</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/#mainsequence.vam_client.utils.build_account_for_venue","title":"<code>build_account_for_venue(execution_venue, account_id, api_key, api_secret)</code>","text":"<p>Creates the account for a venue</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/utils/#mainsequence.vam_client.utils.build_accounts_for_venues","title":"<code>build_accounts_for_venues(venue_symbols, rebuild_assets=True)</code>","text":"<p>Creates all the accounts for a list of venues in VAM</p>"},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/maintenance/accounts/","title":"Accounts","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts","title":"<code>mainsequence.vam_client.maintenance.accounts</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts.AccountLooper","title":"<code>AccountLooper</code>","text":""},{"location":"/home/jose/code/MainSequenceClientSide/mainsequence-sdk/docs/reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts.AccountLooper.update_account_loop","title":"<code>update_account_loop(account, logger)</code>  <code>staticmethod</code>","text":"<p>This methoods runs one account update (1) sync funds (2) Very risk parameters for an unwind</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>Account</code> required"},{"location":"getting_started/TDAG/","title":"Welcome to TDAG","text":"<p>TDAG  is a cutting-edge, graph-based library designed specifically for building and managing time-series data pipelines. With TDAG, you can create automated, time-based dependency structures that are robust, efficient, and ready for real-world, scalable applications.</p> <p>At its core, TDAG leverages the power of DAGs (Directed Acyclic Graphs). A DAG is a graph with nodes connected by edges, where the edges have a direction, and no cycles (loops) exist. In simpler terms, this structure allows data to flow in one direction without any feedback loops, which is essential for building reliable and predictable data pipelines. The \"time-directed\" aspect in TDAG makes it ideal for handling time-sensitive operations, ensuring that tasks occur in the correct sequence.</p>"},{"location":"getting_started/TDAG/#why-tdag","title":"Why TDAG?","text":"<p>With TDAG, you can automatically create time-based data pipelines that handle complex dependencies. The library provides features such as automatic hashing, seamless scheduling integration, and a structured approach that enhances the reliability and scalability of your pipelines.</p>"},{"location":"getting_started/TDAG/#key-features","title":"Key Features:","text":"<ul> <li>Automated Time-Based Pipelines: TDAG allows you to easily build data pipelines where tasks are executed in time order, respecting dependencies.</li> <li>Built-in Scheduling and Hashing: Pipelines are automatically hashed and scheduled for efficient execution.</li> <li>Scalable &amp; Robust: Whether you're working on small datasets or massive time-series data flows, TDAG scales to meet your needs while ensuring the entire process is fault-tolerant and robust.</li> </ul>"},{"location":"getting_started/TDAG/#use-case-investment-strategies-and-beyond","title":"Use Case: Investment Strategies and Beyond","text":"<p>One of TDAG's main use cases is transforming raw financial data into actionable insights, such as investment strategy predictions or portfolio weights. TDAG simplifies the process of managing complex time-based operations in financial modeling, helping you move from data to decisions effortlessly.</p> <p>However, TDAG is not just limited to finance! It's perfect for any application requiring time-sensitive data pipelines, particularly in live and online modes where real-time decision-making is crucial. For example, TDAG can be used in online training of machine learning models, where time-based data flow and immediate processing are essential for model accuracy and performance.</p>"},{"location":"getting_started/TDAG/#why-use-a-dag","title":"Why Use a DAG?","text":"<p>A DAG (Directed Acyclic Graph) is a graph structure where: 1. Directed: Each connection (edge) between nodes points in a specific direction, indicating the flow of data or dependencies. 2. Acyclic: There are no cycles, meaning that no node in the graph can loop back to itself. This is critical for tasks that need to happen in a specific sequence.</p> <p>In the context of TDAG, a DAG ensures that all data processing happens in the correct order, and no task is repeated or stuck in a loop. When applied to time-series data pipelines, this means that your data will always flow from the past to the present in a structured, predictable manner, ensuring that dependencies are handled properly and efficiently.</p>"},{"location":"getting_started/TDAG/#the-power-of-tdag","title":"The Power of TDAG","text":"<p>Whether you\u2019re managing financial data pipelines or real-time machine learning workflows, TDAG is designed to give you the control, scalability, and reliability you need to handle complex, time-sensitive data with ease.</p> <p>Start by exploring our Getting Started Tutorial or jump into the Code Reference if you're already familiar with TDAG.</p> <p>If you are looking for more resources you can also access our vidoe tutorials on TDAG here:</p> <ul> <li>Main Sequence SDK Tutorial:  1 Introduction to TDAG</li> <li>Main Sequence SDK Tutorial:  2 Introduction to TimeSeries</li> <li>Main Sequence SDK Tutorial:  3 Introduction to Schedulers</li> </ul>"},{"location":"getting_started/TDAG/tutorial/Introduction_part1/","title":"Part 1: TimeSeries","text":"<p>Let\u2019s start with a simple example and progressively build upon it. Suppose we want to replicate a fund for which we don\u2019t know the exact components\u2014this could be an ETF (Exchange-Traded Fund) or a closed-end fund. Since we don\u2019t know the components, we will adopt a data-driven approach to estimate the underlying assets.</p> <p>To make it more concrete, let\u2019s assume we want to replicate the S&amp;P 500 Financial Sector. A good proxy for this sector is the XLF ETF. Our goal is to replicate the performance of XLF by identifying its components using historical data. Since we don't have the exact components, we'll run a regularized rolling regression.</p> <p>For regularization, we\u2019ll use Lasso (Least Absolute Shrinkage and Selection Operator) because it has the desirable property of setting certain weights to zero due to its L1 regularization, effectively selecting only the most important assets in our replication.</p>"},{"location":"getting_started/TDAG/tutorial/Introduction_part1/#rolling-regression-with-lasso","title":"Rolling Regression with Lasso","text":""},{"location":"getting_started/TDAG/tutorial/Introduction_part1/#1-fixed-window-regression-pseudo-code","title":"1. Fixed Window Regression (Pseudo-code)","text":"<p>Before we dive into rolling regressions, let's first outline the process for a fixed window regression using Lasso:</p> <ul> <li>Collect the historical returns for XLF and the individual stocks from the S&amp;P 500 Financial Sector.</li> <li>Run the Lasso regression for a given period (e.g., last 60 days).</li> <li>Use the Lasso coefficients to identify the most important stocks for that period.</li> </ul> <p>In pseudo-code:</p> <pre><code># Pseudo-code for fixed window Lasso regression\nfor each window in historical_data:\n    X = get_returns_for_stocks_in_window(window)\n    y = get_returns_for_XLF_in_window(window)\n    model = Lasso(alpha=\u03bb)  # \u03bb is the regularization parameter\n    model.fit(X, y)\n    coefficients = model.coef_\n    select_significant_assets(coefficients)\n</code></pre>"},{"location":"getting_started/TDAG/tutorial/Introduction_part1/#2-maintainability-of-our-pipeline","title":"2. Maintainability of Our Pipeline**","text":"<p>What we want to achieve now is to write the code that performs this rolling regression and have a system that runs this code automatically, say every day at 11 PM. Additionally, we need to ensure that the results are persisted so they can be extracted, reused, and integrated into other processes. Of course, we want to accomplish this in a simple and extendable way. This is where our first Tdag Helper comes in: a TimeSerie object.</p>"},{"location":"getting_started/TDAG/tutorial/Introduction_part1/#tdag-time-series","title":"Tdag Time Series","text":"<p>In simple terms, a Tdag TimeSerie is an object of type <code>TimeSerie</code> that controls the following three main tasks:</p> <ol> <li>Updating Logic: It contains the logic for updating a time series based on its last update.</li> <li>Linked to Storage: It is linked to a storage solution. By default, we use TimeScaleDB for storing the data.</li> <li>Uniqueness Guarantee: It guarantees that the persisted data is unique for each combination of parameters.</li> </ol> <p>For example, if we have a <code>TimeSerie</code> that performs a rolling regression using the last 100 days of data, this <code>TimeSerie</code> should be different from a <code>TimeSerie</code> that uses the last 200 days. This ensures the uniqueness of each time series instance based on its specific configuration.</p> <pre><code>graph TD\n    A[TimeSerie: XLF Returns] --&gt; B[TimeSerie: Lasso Regression: 100 Days]\n    A --&gt; E[TimeSerie: Lasso Regression: 200 Days]\n\n    B --&gt; |to Timescale DB| D[DB Table for : TimeSerie: Lasso Regression: 100 Days]\n    E --&gt; |to Timescale DB| G[DB Table for : TimeSerie: Lasso Regression: 200 Days]\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class D purple;\n    class G purple;\n</code></pre> <p>To achieve this structure, TDAG will automatically handle the hashing process and ensure that we have two distinct sets of data based on our arguments. Let's see how we can achieve this in code.</p> <p>First, we extend the TimeSerie class with the arguments that we require; in this case, these are the size of the rolling window and the regularization parameter. The decorator <code>@TimeSerie._post_init_routines</code> is necessary to perform all the magic behind TDAG.</p> <pre><code>from mainsequence.tdag import TimeSerie\nfrom utils import BarTimeSerie\n\n\ndef get_prices_bars():\n    ...\n\n\nclass ETFReplicator(TimeSerie):\n\n    @TimeSerie._post_init_routines()\n    def __init__(self, lasso_alpha: float, in_window: int = 60, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.in_window = in_window\n        self.lasso_alpha = lasso_alpha\n        self.bars_ts = BarsTimeSerie()  # a time serie with the prices\n</code></pre> <p>As you can see, the initialization is quite simple. We just need to define the parameters that will uniquely define our time series: in this case, <code>lasso_alpha</code> and <code>in_window</code>. It is important to mention that we are referencing another time series with <code>BarTimeSerie</code>.</p> <p>Now the next step is to add the logic to get the coefficients. This is also quite simple. Here, we use the TimeSerie method <code>get_df_from_table_after_date</code> to retrieve only the new data that we need. Important observations are:</p> <ol> <li>If latest_value is None, it means that the time series has never been updated, so we need to handle this logic.</li> <li>We always use UTC dates in the database to ensure compatibility.</li> </ol> <pre><code>from mainsequence.tdag import TimeSerie\n\n\ndef get_lasso_coefficients():\n    ...\n\n\nclass ETFReplicator(TimeSerie):\n    def update_series_from_source(self, latest_value: Union[datetime, None], *args, **kwargs) -&gt; pd.DataFrame:\n        if latest_value is None:\n            latest_value = datetime.datetime(2010, 1, 1).replace(tzinfo=pytz.utc)\n        start_value = latest_value - datetime.timedelta(days=self.in_window)\n        prices = self.bars_ts.get_df_from_table_after_date(start_value)\n\n        prices = prices.reset_index().pivot_table(index='time_index', columns='asset_symbol',\n                                                  values=self.assets_configuration.price_type.value)\n        weights = get_lasso_coefficients(prices, self.lasso_alpha)\n        return weights\n</code></pre> <p>And thats all with only this lines of code this pipeline will be updated systmetaically and persisted into our database Lets get a litte more complicated. As you perhaps noticed in the previous code we are not defining at any point the asset that we want to replicate so we should add this to the initialization. Now also lets suppose that we want to build a portfolio that goes long a replication of the XLF and goes short a replication of XLE which is the energy sector of the S&amp;P500.</p> <p>Also, for the sake of stability, let\u2019s build this portfolio where each leg is the average weight of the 100-day and 200-day rolling regression. For sake of simplicit lets leave on lasso_alpha for all regression but this is something we could easily change.</p> <p>First, let\u2019s modify our initialization method to include the ticker that we want to replicate.</p> <pre><code>class ETFReplicator(TimeSerie):\n\n    @TimeSerie._post_init_routines()\n    def __init__(self, lasso_alpha: float, ticker_to_replicate: str, in_window: int = 60, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        ...\n</code></pre> <p>now lets look at how our portfolio <code>TimeSerie</code> will look like</p> <pre><code>class LongShortPortfolio(TimeSerie):\n    @TimeSerie._post_init_routines()\n    def __init__(self, ticker_long: str, ticker_short: str, long_roling_windows: list, lasso_alpha: float,\n                 short_rolling_windows: list, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        long_ts = {f\"ts_{i}\": ETFReplicator(lasso_alpha=lasso_alpha, ticker_to_replicate=ticker_long,\n                                            in_window=i\n                                            ) for i in long_roling_windows}\n        short_ts = {f\"ts_{i}\": ETFReplicator(lasso_alpha=lasso_alpha, ticker_to_replicate=ticker_long,\n                                             in_window=i\n                                             ) for i in short_rolling_windows}\n        self.long_ts = long_ts\n        self.short_ts = short_ts\n        self.lasso_alpha=lasso_alpha\n\n\nlong_short_portfolio = LongShortPortfolio(ticker_long=\"XLF\", ticker_short=\"XLE\", long_rolling_windows=[100, 200, ],\n                                          short_rolling_windows=[100, 200],lasso_alpha=1e-2\n                                          )\n</code></pre> <p>That\u2019s all! With only these few lines of code, we have a fully integrated data pipeline that will update our portfolio automatically. What is more important on this example is how you can build the pipelines as building blocks but agnostic  of how the previous block was build. you dont even neeed to know from how many other TimeSeries this block belongs.  This process make it extremely powerfull to stack while keeping a clean and lean code. </p> <p>The graph of this pipeline should look something like this:</p> <pre><code>graph TD\n    A[TimeSerie: XLF Returns] --&gt; B[TimeSerie:  XLF Lasso Regression: 100 Days]\n    A --&gt; E[TimeSerie: XLF Lasso Regression: 200 Days]\n\n    A[TimeSerie: XLF Returns] --&gt; B_1[TimeSerie:  XLE Lasso Regression: 100 Days]\n    A --&gt; E_1[TimeSerie: XLE Lasso Regression: 200 Days]\n\n\n    B --&gt; |to Timescale DB| D[DB Table for : XLF TimeSerie: Lasso Regression: 100 Days]\n    E --&gt; |to Timescale DB| G[DB Table for : XLF TimeSerie: Lasso Regression: 200 Days]\n\n    B_1 --&gt; |to Timescale DB| D_1[DB Table for : XLE TimeSerie: Lasso Regression: 100 Days]\n    E_1 --&gt; |to Timescale DB| G_1[DB Table for : XLE TimeSerie: Lasso Regression: 200 Days]\n\n    D --&gt; |to portfolio TS | last[TimeSerie: Long Short Portfolio]\n    G --&gt; |to portfolio TS| last\n\n    D_1 --&gt; |to portfolio TS | last\n    G_1 --&gt; |to portfolio TS| last\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class D purple;\n    class G purple;\n    class D_1 purple;\n    class G_1 purple;\n</code></pre> <p>As you can see, even with this simple example, the pipelines are becoming increasingly complex. Now imagine integrating data from a different source\u2014let\u2019s say U.S. economic data from the Federal Reserve. Perhaps you also want to interpolate or filter the prices in a specific way. What about adding sentiment analysis from internet searches? And how about a machine learning model that requires feeding with thousands of different signals and needs to be retrained every two weeks?</p> <p>This is just for one pipeline tied to a single portfolio. Now imagine wanting to maintain multiple portfolios, each tailored for different profiles. Surely, you wouldn\u2019t want to manage this using a spreadsheet or countless Jupyter notebooks, right?</p> <p>now lets look at how we can start scheduling our pipelines. continue to Part 2 Running Pipelines</p>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/","title":"Part 2: Running Pipelines","text":"<p>In the previous section, we saw how we can build our pipelines. Now, in this section, let's look at how we can start running them. In TDAG, we have mainly three ways of running our pipelines:</p> <ol> <li>We run our pipelines as a single continuous process, persisting and reading from our database in DEBUG Mode.</li> <li>We run our pipelines as a separate distributed process, where we can scale each node in the graph into a Ray cluster.</li> <li>We can run locally using Parquet data without interacting with the database. This method is very useful for running    fast iterations before we persist something in the database. Because, as you can imagine, continuous queries to a    database within a loop can incur time overhead.</li> </ol>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#running-with-tdag-schedulers","title":"Running with TDAG Schedulers","text":"<p>for the first two methods we will use <code>Schedulers</code> this object is in charge of organizing and coordinating the update of time series. The reason of why we have sveral schedulers and not only one scheduler its because this helps to maintain isolated enviroments bewteen different time series even when they become to the same pipeline lets look at one example</p> <p>Making reference to our previous example we can have one scheduler that is in charge of updating all our pipeliens which uses an environment of scikit learn , while we can have another scheduler that updates pipelines on an environment that requires heavy machine learning libraries like Rapids and Pytorch in this case we will have somthing like this.</p> <pre><code>graph TD\n    A[Scheduler: For scikit learn environment] --&gt; B[TimeSerie: Type 1]\n    A --&gt; E[TimeSerie: Type 2]\n\n    E --&gt; E1[Intermediate Time Series]\n    B --&gt; B1[Intermediate Time Series]\n\n    E1 --&gt;P[TimeSeries:Prices]\n    B1 --&gt;P\n\n    A_P[Scheduler: For Nvidia environment] --&gt; B_P[TimeSerie: Type 2]\n    A_P --&gt; E_P[TimeSerie: Type 2]\n\n    E_P --&gt; E1_P[Intermediate Time Series]\n    B_P --&gt; B1_P[Intermediate Time Series]\n\n    E1_P --&gt;P\n    B1_P --&gt;P   \n\n\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class A purple;\n    class A_P purple;\n\n</code></pre> <p>As you can see in the example above, schedulers can have different configurations and mixed time series dependencies. If a time series is dependent on a particular environment, you can isolate it and allow a specific scheduler to update it only. You can also let a time series be updated by the next available scheduler. You don't need to worry; this all happens in the background. As you will see, setting it up is quite simple.</p>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#scheduler-in-debug-mode","title":"Scheduler in debug mode","text":"<p>To Run a scheduler in debug mode first you need to create the time serie that you want to run</p> <pre><code>from mainsequence.tdag import SchedulerUpdater\n\ntime_serie = ETFReplicator(lasso_alpha=.01, ticker_to_replicate=\"SPY\", in_window=100)\nSchedulerUpdater.debug_schedule_ts(\n    time_serie_hash_id=time_serie.local_hash_id,\n    break_after_one_update=True,\n    debug=True,\n    update_tree=True,\n)\n</code></pre> <p>That is all! This will start a process in which the full tree will be executed sequentially. Notice that we are using the class method <code>debug_schedule_ts</code>. What this method does is generate a new scheduler on the fly and execute the time series in this scheduler. We could also start it in the following way:</p> <pre><code>from mainsequence.tdag import SchedulerUpdater, Scheduler\n\nscheduler = Scheduler.build_and_assign_to_ts(scheduler_name=s_name, local_hash_id_list=[time_serie.local_hash_id],\n                                             delink_all_ts=False)\nSchedulerUpdater.start(scheduler=scheduler, break_after_one_update=True,\n                       debug=True,\n                       update_tree=True, )\n</code></pre> <p>Now lets dig on the arguments</p> <ul> <li>time_serie_hash_id: As discussed previously, all time series are uniquely hashed. However, there are scenarios   where we need more than one hash. For example, imagine that we have a time series that depends only on the prices of 2   stocks, and another that depends on the prices of 500. We don't want to create a table for 2 stocks and another table   for 500; what we want is to have two processes that update the same table with all our stocks. To achieve this, we can   set a property in our time series called <code>ignore_local_kwargs</code>. This property will indicate which arguments we should   ignore when creating the table, while the others will be used to hash the process. For example, like this:</li> </ul> <pre><code>graph TD\n    A[TimeSerie: updates only 2 assets prices] --&gt; B[DB Table: All Prices]\n    C[TimeSerie: updates 500 assets prices] --&gt; B[DB Table: All Prices]\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class B purple;\n\n</code></pre> <ul> <li>break_after_one_update: Setting this to True indicates that we want to perform only one loop rather than   continuously having the process be updated.</li> <li>debug: Run in debug mode in a single process.</li> <li>update_tree: Update all the dependencies of the time series being scheduled.</li> </ul>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#scheduler-in-live-mode","title":"Scheduler in live mode","text":"<p>While the scheduler in debug mode is handy for testing our pipelines, we want to harness the full power of distributed and auto-scalable systems to manage all our pipelines, regardless of their complexity. Let's go back to our original example of the ETF replicator and assume that when we update the prices, we can take advantage of parallelization.</p> <p>Imagine you are requesting prices from an API, allowing you to make batch requests using several cores instead of relying on a single loop. In this case, you may want to set the <code>TimeSerie</code> <code>BarPrices</code> to use perhaps 10 CPUs, while the other time series might use only 1 CPU. Alternatively, you might want one time series to use 10 CPUs and 1 GPU.</p> <p>This and any other configuration is possible thanks to TDAG, leveraging Ray as our cluster manager. By using Ray, we can easily distribute and parallelize our pipelines and set the requirements we need for each <code>TimeSerie</code>.</p> <p>Going back to our previous example the difference between live and debug mode can be observed in the same time serie running differently</p>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#scheduler-in-live-mode-graph","title":"Scheduler in live mode graph","text":"<pre><code>graph TD\n    A[TimeSerie: XLF Returns] --&gt; B[TimeSerie: XLF Lasso Regression: 100 Days]\n    A --&gt; E[TimeSerie: XLF Lasso Regression: 200 Days]\n\n    A[TimeSerie: XLE Returns] --&gt; B_1[TimeSerie: XLE Lasso Regression: 100 Days]\n    A --&gt; E_1[TimeSerie: XLE Lasso Regression: 200 Days]\n\n    B --&gt; |to Timescale DB| D[DB Table for: XLF TimeSerie: Lasso Regression: 100 Days]\n    E --&gt; |to Timescale DB| G[DB Table for: XLF TimeSerie: Lasso Regression: 200 Days]\n\n    B_1 --&gt; |to Timescale DB| D_1[DB Table for: XLE TimeSerie: Lasso Regression: 100 Days]\n    E_1 --&gt; |to Timescale DB| G_1[DB Table for: XLE TimeSerie: Lasso Regression: 200 Days]\n\n    D --&gt; |to Portfolio TS| last[TimeSerie: Long Short Portfolio]\n    G --&gt; |to Portfolio TS| last\n\n    D_1 --&gt; |to Portfolio TS| last\n    G_1 --&gt; |to Portfolio TS| last\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class D purple;\n    class G purple;\n    class D_1 purple;\n    class G_1 purple;\n</code></pre>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#scheduler-in-debug-mode-graph","title":"Scheduler in debug mode graph","text":"<pre><code>graph TD\n    A[TimeSerie: XLF Returns] --&gt; B[TimeSerie: XLF Lasso Regression: 100 Days]\n    B --&gt; C[DB Table for: XLF TimeSerie: Lasso Regression: 100 Days]\n    C --&gt; D[TimeSerie: XLF Lasso Regression: 200 Days]\n    D --&gt; E[DB Table for: XLF TimeSerie: Lasso Regression: 200 Days]\n\n\n    E--&gt; H[TimeSerie: XLE Lasso Regression: 100 Days]\n    H --&gt; I[DB Table for: XLE TimeSerie: Lasso Regression: 100 Days]\n    I --&gt; J[TimeSerie: XLE Lasso Regression: 200 Days]\n    J --&gt; K[DB Table for: XLE TimeSerie: Lasso Regression: 200 Days]\n    K --&gt; L[TimeSerie: Long Short Portfolio]\n\n    classDef purple fill:#DDA0DD,stroke:#000,stroke-width:2px;\n    class C,E,I,K purple;\n\n</code></pre>"},{"location":"getting_started/TDAG/tutorial/running_time_series_part2/#running-with-data-lake","title":"Running with Data Lake","text":"<p>While the previous two ways of running the pipelines are designed for maintainability, explorability, and clarity, we realized that there is a need for a different approach to building our pipelines that could help researchers go through the full process in a more streamlined way. This is particularly important if we want to run loops and analyses on them.</p> <p>Let\u2019s go back to our Long Short portfolio and imagine that we want to observe the hyperspace of portfolios generated by several combinations of parameters. If we fix the tickers, we have combinations of rolling windows and regularization parameters, which takes us to a four-dimensional space. In this case, we don\u2019t want to persist any iteration in the database; perhaps we just want to see at which point the interaction of the regularization parameters starts to decrease, for example, or at which point our regression starts to stabilize. For these scenarios, we can run our pipelines in Data Lake mode.</p> <p>Let\u2019s look at a code example to understand it better.</p> <pre><code>data_lake_yaml_configuration = \"\"\"\ndatalake_end: 2024-09-01 00:00:00\ndatalake_name: Long short portofolio\ndatalake_start: 2022-08-01 00:00:00\nnodes_to_get_from_db: interpolatedpricestrain_c9676700655ba6d948919ca925ca82c1\npersist_logs_to_file: false\n\"\"\"\ntotal_return = []\nfor rolling_window in range(60, 30 * 24, 20):\n    for lasso_alpha in [1, 1e-2, 1e-3, 1e-4, 1e-5]:\n        long_short_portfolio = LongShortPortfolio(ticker_long=\"XLF\", ticker_short=\"XLE\",\n                                                  long_rolling_windows=[long_rollling_window],\n                                                  short_rolling_windows=[100, 200], lasso_alpha=1e-2\n                                                  )\n        portfolio_df = long_short_portfolio.get_df_greater_than_in_table(latest_value=None)\n        total_return.append(long_short_portfolio[\"portfolio\"].iloc[-1] - 1)\n</code></pre> <p>In the previous example, if we run in Data Lake mode, each of the TimeSeries will be dumped once from the database into a Data Lake as a Parquet file. The Data Lake will be configured in a folder structure of the following form:</p> <pre><code>DataLakeName/\n\u251c\u2500\u2500 DateRange/\n\u2502   \u251c\u2500\u2500 TimeSeriesHash1/parquet_partitions\n\u2502   \u251c\u2500\u2500 TimeSeriesHash2/parquet_partitions\n\u2502   \u251c\u2500\u2500 TimeSeriesHash3/parquet_partitions\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre> <p>Additionally, if we want, we can keep some TimeSeries cached in memory that are constantly being reused. This increases the speed at which we can run our pipelines by approximately 100 times, as we read mostly from memory or disk, avoiding networking and database overhead.</p> <p>To run a TimeSeries in Data Lake mode, we only need to call the method <code>get_df_greater_than_in_table</code> of the <code>TimeSerie</code> we want to calculate, and the tree will be updated automatically.</p> <p>Now, let\u2019s look at how we can visualize and manage all our pipelines in the GUI. Continue to Part 3: The TDAG Explorer.</p>"},{"location":"getting_started/TDAG/tutorial/tdag_explorer_part3/","title":"Part 3: TDAG Explorer","text":"<p>In the previous two parts we learned how can we easily build and schedule Time Series Pipelines now lets see how  can we monitor , manage and explor them in a unified web interface. </p> <p>TDAG Enterprise gives you access to complete GUI for observability in this GUI you can:</p>"},{"location":"getting_started/TDAG/tutorial/tdag_explorer_part3/#1-search-and-visualize-your-tables-by-type-of-pipeline","title":"1 Search and visualize your tables by type of pipeline","text":""},{"location":"getting_started/TDAG/tutorial/tdag_explorer_part3/#2-search-and-visualize-your-time-series-processes","title":"2 Search and visualize your Time Series Processes","text":""},{"location":"getting_started/TDAG/tutorial/tdag_explorer_part3/#search","title":"Search","text":""},{"location":"getting_started/TDAG/tutorial/tdag_explorer_part3/#visualize-its-build-and-update-detail","title":"Visualize its build and update detail","text":""},{"location":"key_concepts/time_series_fundamentals/","title":"Time Series Fundamentals","text":"<p>The core of TDAG is the TimeSerie class. A TDAG TimeSerie uniquely defines a process responsible for updating a time series based on the last available value.</p> <p>An update process in terms of TDAG involves the following:</p> <p>Updating a DataRepository with the new data generated by the pipeline process. Updating an ORM with the state of the data and the pipeline's updates.</p> <p>The <code>TimeSerie</code> class is primarily defined by two key methods:</p> <ol> <li>The <code>__init__</code> method, which constructs the initial details and configuration of the class.</li> <li>The <code>update_series_from_source(latest_value=None)</code> method, which handles updating the time series with new data    starting from the latest value.</li> </ol> <p>By defining these two methods, it will be enough to make a time series work and be able to interconnect with other time series.</p> <pre><code>flowchart TD\n    subgraph TDAG_System[TDAG Framework]\n         TimeSerieConstructor[\"TimeSerie.__init__(*args, **kwargs)\"] --&gt;|Defines| TimeSerie[\"TimeSerie.update_series_from_source(latest_value)\"]\n    end\n\n    subgraph DataRepositories[\"Data Repositories\"]\n        DB[\"TimeScaleDB\"]\n        DataLake[\"DataLake\"]\n    end\n\n    subgraph ORM[\"TDAG ORM\"]\n\n        LocalTimeSerie[\"LocalTimeSerie (local_hash_id)\"]  --&gt;|View of Table| DynamicTable[\"DynamicTable (hash_id)\"]\n    end\n\n    TimeSerie --&gt;|Updates| DataRepositories\n    TimeSerie --&gt;|Updates| ORM\n     ORM --&gt;|Manages state of| DataRepositories\n    ORM --&gt;|Updates| DynamicTable\n    ORM --&gt;|Updates| LocalTimeSerie\n</code></pre> <p>Let\u2019s dive into the details of each of these methods.</p>"},{"location":"key_concepts/time_series_fundamentals/#__init__-method","title":"<code>__init__</code> Method","text":"<pre><code>def __init__(self, init_meta=None,\n             build_meta_data: Union[dict, None] = None,\n             local_kwargs_to_ignore: Union[List[str], None] = None,\n             data_configuration_path: Union[str, None] = None,\n             *args, **kwargs):\n    ...\n</code></pre> <p>The <code>__init__</code> method is particularly important in TDAG as it helps us hash the process and, hence, link it to our data repository. All the arguments in the <code>__init__</code> method will be used to create two unique hashes:</p> <ol> <li>hash_id: Represents the unique hash of the data repository linked to the <code>TimeSerieProcess</code>.</li> <li>local_hash_id: Represents the unique hash of the process that is updating the data repository.</li> </ol> <p>It is easier to understand why we need hashing when we look at an example. Imagine that you have two different portfolios represented as a TDAG. One portfolio uses prices from financial sector stocks, while the other portfolio uses prices from technology stocks. Both pipelines depend on the <code>TimeSerie</code> for stock prices. However, we don\u2019t want to update the database of prices for all stocks when we only need updates for financial or technology stocks. At the same time, we also don\u2019t want to have separate tables for each subsection of stocks.</p> <p>TDAG helps us with this by creating a unique <code>hash_id</code> for the table that holds the prices and a unique <code>hash_id</code> for the process that will be updating this table.</p> <p>All the arguments of the constructor (<code>__init__</code>) will be used to create these hashes, with the exception of the following:</p> <ul> <li>init_meta: This is arbitrary metadata that can be passed during initialization. In more advanced examples, we may   encounter cases where several time series have the same dependencies, so this can help in construction.</li> <li>build_meta_data: This is metadata that does not get included in the time series hash but can be recovered at any   point. For example, if we have a <code>TimeSerie</code> that points to a database and we want the address to remain unhashable   and editable from the front end, we can set it up here.</li> <li>local_kwargs_to_ignore: This is a list of strings with the names of the arguments that will be excluded from *   hash_id but not from local_hash_id*.</li> </ul> <p>By last it is important that everytime we build a TimeSeries we decorate the <code>__init__</code> constructor in the following way</p> <pre><code>from mainsequence.tdag import TimeSerie\n\n\nclass NewTimeSeries(TimeSerie):\n    @TimeSerie._post_init_routines\n    def __init__(self):\n        ...\n</code></pre>"},{"location":"key_concepts/time_series_fundamentals/#timeseries-dependencies","title":"TimeSeries Dependencies","text":"<p>The <code>__init__</code> method is also responsible for building the dependency tree of each of our TimeSeries. In contrast to other data pipeline managers, TDAG performs code introspection, which allows us to only declare the direct dependencies of a time series. The only thing we need to do is declare the dependencies as attributes in our constructor, for example.</p> <pre><code>class NewTimeSeries(TimeSerie):\n    @TimeSerie._post_init_routines\n    def __init__(self, asset_symbols: List[str], *args, **kwargs):\n        self.prices_time_serie = PricesTimeSerie(asset_symbols=asset_symbols)\n</code></pre>"},{"location":"key_concepts/time_series_fundamentals/#timeseries-pickle","title":"TimeSeries Pickle","text":"<p>Each <code>TimeSeries</code> instance saves its state as a pickle file upon its first initialization. This approach speeds up the loading process for time series data. Once a time series is pickled, all subsequent updates within a TDAG pipeline will use the pickled object.</p> <p>Each time a time series is pickled, its code is hashed, and a unique identifier is assigned. This allows TDAG to determine when the time series needs to be re-pickled. To ensure the pickled time series remains up-to-date, every <code>TimeSeries</code> instance introspects itself on initialization, comparing its current code hash with the hash stored in the TDAG explorer. If the hashes differ, the <code>TimeSeries</code> instance will be rebuilt instead of loaded from the pickle.</p>"},{"location":"key_concepts/time_series_fundamentals/#update_series_from_source-method","title":"<code>update_series_from_source</code> Method","text":"<pre><code>   def update_series_from_source(self, latest_value: Union[None, datetime.datetime], *args, **kwargs) -&gt; pd.DataFrame:\n    \"\"\"\n    This method performs all the necessary logic to update our time series. The method should always return a DataFrame with the following characteristics:\n\n    1) A unidimensional index where the index is of the type `DatetimeIndex` and the dates are in `pytz.utc`.\n    2) A multidimensional index that should always have 3 dimensions: `time_index` (with the same characteristics as before), `asset_symbol`, and `execution_venue_symbol`.\n\n    Parameters\n    ----------\n    latest_value\n    args\n    kwargs\n\n    Returns\n    -------\n\n    \"\"\"\n</code></pre> <p>This method performs all the necessary logic to update our time series. The method should always return a DataFrame with the following characteristics:</p> <p>1) A unidimensional index where the index is of the type <code>DatetimeIndex</code> and the dates are in <code>pytz.utc</code>. 2) A multidimensional index that should always have 3 dimensions: <code>time_index</code> (with the same characteristics as    before), <code>asset_symbol</code>, and <code>execution_venue_symbol</code>.</p> <p>As can be seen in the signature of the method, <code>latest_value</code> can be <code>None</code>. When the value is <code>None</code>, it means that the TimeSerie has never been updated successfully before. When it is not <code>None</code>, it will give us the latest value in our data repository for this time series.</p>"},{"location":"key_concepts/time_series_fundamentals/#other-methods-to-perform-updates","title":"Other methods to perform updates","text":"<p>While the previous two methods are enough to perform updates, there are many cases in which we need additional helpers to make the update seamless. I will describe in detail some of the most commonly used methods.</p>"},{"location":"key_concepts/time_series_fundamentals/#get_df_greater_than_in_table","title":"<code>get_df_greater_than_in_table</code>","text":"<pre><code>def get_df_greater_than_in_table(self, target_value: Union[None, datetime.datetime],\n                                 great_or_equal=False,\n                                 force_db_look=True, symbol_list: Union[None, list] = None,\n                                 ) -&gt; pd.DataFrame:\n    ...\n</code></pre> <p>This method gives you the data in the repository greater than the <code>target_value</code>. It is helpful for retrieving data for dependencies during the update process. In several methods, we will encounter the <code>symbol_list</code> argument, which helps filter requests by the second axis of a multi-index, specifically the <code>asset_symbol</code>.</p>"},{"location":"key_concepts/time_series_fundamentals/#get_last_observation","title":"<code>get_last_observation</code>","text":"<pre><code>def get_last_observation(self, asset_symbols: Union[None, list] = None,\n                         ):\n</code></pre> <p>Returns the last observation of a TimeSerie as a pandas DataFrame</p>"},{"location":"key_concepts/time_series_fundamentals/#the-wrappertimeserie-class","title":"The WrapperTimeSerie Class","text":"<pre><code>class WrapperTimeSerie(TimeSerie):\n    \"\"\"A wrapper class for managing multiple TimeSerie objects.\"\"\"\n\n    @TimeSerie._post_init_routines()\n    def __init__(self, time_series_dict: Dict[str, TimeSerie], *args, **kwargs):\n</code></pre> <p>The <code>WrapperTimeSerie</code> class is an intermediate helper class that helps us group several <code>TimeSerie</code> instances in a declarative form. This helper class is useful when we have a group of similar time series, and we want to manage them together.</p> <pre><code>graph TD\n    %% First Chart: Several TimeSeries connect to a single TimeSerie\n    subgraph Chart1[\"Multiple TimeSeries to a Single TimeSerie\"]\n        TS1[\"TimeSerie 1\"] --&gt; MainTimeSerie[\"Main TimeSerie\"]\n        TS2[\"TimeSerie 2\"] --&gt; MainTimeSerie\n        TS3[\"TimeSerie 3\"] --&gt; MainTimeSerie\n    end\n\n    %% Second Chart: Multiple TimeSeries connect to WrapperTimeSerie, then WrapperTimeSerie connects to Main TimeSerie\n    subgraph Chart2[\"TimeSeries to WrapperTimeSerie to Main TimeSerie\"]\n        TS4[\"TimeSerie 1\"] --&gt; WrapperTimeSerie[\"WrapperTimeSerie\"]\n        TS5[\"TimeSerie 2\"] --&gt; WrapperTimeSerie\n        TS6[\"TimeSerie 3\"] --&gt; WrapperTimeSerie\n        WrapperTimeSerie --&gt; MainTimeSerie2[\"Main TimeSerie\"]\n    end\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>tdag<ul> <li>config</li> <li>contrib<ul> <li>feature_factory<ul> <li>bar_features</li> <li>bar_time_series</li> <li>utils</li> </ul> </li> <li>utils</li> </ul> </li> <li>distributed<ul> <li>time_series</li> <li>utils</li> </ul> </li> <li>instrumentation<ul> <li>utils</li> </ul> </li> <li>logconf</li> <li>time_series<ul> <li>persist_managers</li> <li>time_series</li> <li>update<ul> <li>api</li> <li>ray_manager</li> <li>scheduler</li> <li>update_methods</li> <li>utils</li> </ul> </li> <li>utils</li> </ul> </li> <li>utils</li> </ul> </li> <li>tdag_client<ul> <li>data_sources_interfaces<ul> <li>local_data_lake</li> <li>timescale</li> </ul> </li> <li>models</li> <li>utils</li> </ul> </li> <li>vam_client<ul> <li>local_vault</li> <li>maintenance<ul> <li>accounts</li> </ul> </li> <li>models</li> <li>models_alpaca</li> <li>models_binance</li> <li>models_helpers</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/tdag/config/","title":"config","text":""},{"location":"reference/tdag/config/#mainsequence.tdag.config","title":"<code>mainsequence.tdag.config</code>","text":""},{"location":"reference/tdag/logconf/","title":"logconf","text":""},{"location":"reference/tdag/logconf/#mainsequence.tdag.logconf","title":"<code>mainsequence.tdag.logconf</code>","text":""},{"location":"reference/tdag/logconf/#mainsequence.tdag.logconf.console_logger","title":"<code>console_logger(logger_name, application_name, **metadata)</code>","text":"<p>Mockup logger</p>"},{"location":"reference/tdag/logconf/#mainsequence.tdag.logconf.create_logger_in_path","title":"<code>create_logger_in_path(logger_name, logger_file, application_name='tdag', **metadata)</code>","text":"<p>Create a logger that logs to console and file in JSON format.</p>"},{"location":"reference/tdag/logconf/#mainsequence.tdag.logconf.extract_from_record","title":"<code>extract_from_record(_, __, event_dict)</code>","text":"<p>Extract thread and process names and add them to the event dict.</p>"},{"location":"reference/tdag/utils/","title":"utils","text":""},{"location":"reference/tdag/utils/#mainsequence.tdag.utils","title":"<code>mainsequence.tdag.utils</code>","text":""},{"location":"reference/tdag/utils/#mainsequence.tdag.utils.copy_drop_database","title":"<code>copy_drop_database(source_uri, target_uri, source_container_name)</code>","text":"<p>Copies database from one host to the other and guarantees  that  are no broken time series.</p> <p>Parameters:</p> Name Type Description Default <code>source_uri</code> <code>str</code> required <code>target_uri</code> <code>str</code> required <code>source_container_name</code> <code>str</code> required"},{"location":"reference/tdag/contrib/utils/","title":"utils","text":""},{"location":"reference/tdag/contrib/utils/#mainsequence.tdag.contrib.utils","title":"<code>mainsequence.tdag.contrib.utils</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_features/","title":"bar_features","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features","title":"<code>mainsequence.tdag.contrib.feature_factory.bar_features</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.AlphaRV","title":"<code>AlphaRV</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.AlphaRV.__init__","title":"<code>__init__(target_column, beta_rolling_window, include_inputs_var=False, *args, **kwargs)</code>","text":"<p>calcualtes RV of alpha by RV of its components</p> <p>Parameters:</p> Name Type Description Default <code>target_column</code> <code>int</code> required <code>upsample_window</code> required <code>alpha_rolling_window</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.BetaFactorLoading","title":"<code>BetaFactorLoading</code>","text":"<p>               Bases: <code>FeatureBase</code></p> <p>This feature makes a rolling regression of beta columns and finds the loading values for the betas on a cross sectional regression</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.DayCloseToOpenReturn","title":"<code>DayCloseToOpenReturn</code>","text":"<p>               Bases: <code>FeatureBase</code></p> <p>Calcualtes return between days from previous day close to actual day open</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.MACD_hist","title":"<code>MACD_hist</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.MACD_hist.__init__","title":"<code>__init__(fast_window, slow_window, target_column, lag, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>fast_window</code> <code>int</code> required <code>slow_window</code> <code>int</code> required <code>signal_window</code> required <code>target_column</code> <code>str</code> required <code>lag</code> <code>int</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.ReturnFromHighLows","title":"<code>ReturnFromHighLows</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.ReturnFromHighLows.__init__","title":"<code>__init__(buffer_window, numerator_column, denominator_column, agg_fun, *args, **kwargs)</code>","text":"<p>:param buffer_window: window to calculate the return from, sometimes this is needed to avoid capturing a reversal effect. :param args: :param kwargs:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingDollarValueBars","title":"<code>RollingDollarValueBars</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingDollarValueBars.get_historical_sequences","title":"<code>get_historical_sequences(df, sequence_length, target_column)</code>  <code>staticmethod</code>","text":"<p>Get data with historical sequences of desired length :param df: :return:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingResidualAlphaBeta","title":"<code>RollingResidualAlphaBeta</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.RollingResidualAlphaBeta.__init__","title":"<code>__init__(target_column, beta_shift=None, alpha_size=None, normalize_beta=False, upsample_regression_minutes=None, *args, **kwargs)</code>","text":"<p>:param target_column: :param beta_shift: :param alpha_size: :param args: :param kwargs:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SimpleReturn","title":"<code>SimpleReturn</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SimpleReturn.__init__","title":"<code>__init__(lag, return_window, target_column, *args, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lag</code> <code> A positive number represents laggede returns, for example if data frequency is minute , lag is 60</code> required <code>and</code> required <code>return_window</code> <code>int</code> required <code>target_column</code> <code>str</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SmoothSpread","title":"<code>SmoothSpread</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.SmoothSpread.__init__","title":"<code>__init__(target_column, *args, **kwargs)</code>","text":"<p>:param target_column: :param beta_shift: :param alpha_size: :param args: :param kwargs:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.VolumeRatio","title":"<code>VolumeRatio</code>","text":"<p>               Bases: <code>FeatureBase</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.VolumeRatio.__init__","title":"<code>__init__(target_column, numerator_window, *args, **kwargs)</code>","text":"<p>calcualtes teh rolling mean :param target_column: :param denominator_window: :param args: :param kwargs:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_features/#mainsequence.tdag.contrib.feature_factory.bar_features.get_rolling_moving_average","title":"<code>get_rolling_moving_average(old_mean, new_sample, last_sample, rolling_window)</code>","text":"<p>Calculates Rolling Moving avarega :param old_mean: :param new_sample: :param last_sample: :param rolling_windos: :return:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/","title":"bar_time_series","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series","title":"<code>mainsequence.tdag.contrib.feature_factory.bar_time_series</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CommonalityFeature","title":"<code>CommonalityFeature</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CommonalityFeature.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompAssetFeat","title":"<code>CompAssetFeat</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompAssetFeat.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompCrossAssetFeat","title":"<code>CompCrossAssetFeat</code>","text":"<p>               Bases: <code>TimeSerie</code></p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.CompCrossAssetFeat.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory","title":"<code>FeaturesFactory</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory.__init__","title":"<code>__init__(features_list)</code>","text":"<p>:param features_dict: {feature_name:feature_kwargs}</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.FeaturesFactory.build_features","title":"<code>build_features(data_df, logger, upsample_frequency_id, original_latest_value, last_observation, extra_data=None)</code>","text":"<p>:param data_df: dataframe with information up to the  longest feature :param logger: :return:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.build_features_from_upsampled_df","title":"<code>build_features_from_upsampled_df(upsampled_ts, latest_value, features_factory, logger, upsample_frequency_id, bar_frequency_id, extra_data=None, concatenate_with_source=True, last_observation=None)</code>","text":"<p>build function for Bar and portfolio Bars :param latest_value: :param features_factory: :param upsampled_df: :param upsample_frequency_id: :param bar_frequency_id: :return:</p>"},{"location":"reference/tdag/contrib/feature_factory/bar_time_series/#mainsequence.tdag.contrib.feature_factory.bar_time_series.override_features_with_feature_frequency","title":"<code>override_features_with_feature_frequency(input_features, frequency_id, upsample_frequency_id)</code>","text":"<p>cahnges feature frequency according to upsample :param input_features: :return:</p>"},{"location":"reference/tdag/contrib/feature_factory/utils/","title":"utils","text":""},{"location":"reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils","title":"<code>mainsequence.tdag.contrib.feature_factory.utils</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances","title":"<code>RollingDistances</code>","text":""},{"location":"reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances.__init","title":"<code>__init(rolling_window)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>rolling_window</code> <code>int</code> required"},{"location":"reference/tdag/contrib/feature_factory/utils/#mainsequence.tdag.contrib.feature_factory.utils.RollingDistances.dtw","title":"<code>dtw(df)</code>","text":"<p>Calculate the rolling dynamic time warp (DTW) distances between all columns of a DataFrame.</p> <p>Parameters:     df (pandas.DataFrame): The input DataFrame containing the columns.</p> <p>Returns:     dict: A dictionary where the keys are tuples representing column pairs,           and the values are lists of DTW distances corresponding to the rolling windows.</p>"},{"location":"reference/tdag/distributed/time_series/","title":"time_series","text":""},{"location":"reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series","title":"<code>mainsequence.tdag.distributed.time_series</code>","text":""},{"location":"reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series.MLflowTrackingRestApi","title":"<code>MLflowTrackingRestApi</code>","text":""},{"location":"reference/tdag/distributed/time_series/#mainsequence.tdag.distributed.time_series.MLflowTrackingRestApi.get_all_finished_runs_df","title":"<code>get_all_finished_runs_df(experiment_name, include_running=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> required <code>include_running</code> <code>False</code>"},{"location":"reference/tdag/distributed/utils/","title":"utils","text":""},{"location":"reference/tdag/distributed/utils/#mainsequence.tdag.distributed.utils","title":"<code>mainsequence.tdag.distributed.utils</code>","text":""},{"location":"reference/tdag/distributed/utils/#mainsequence.tdag.distributed.utils.get_request_status_from_query","title":"<code>get_request_status_from_query(query, request_url)</code>","text":"<p>:param query: :type query: :return: :rtype:</p>"},{"location":"reference/tdag/instrumentation/utils/","title":"utils","text":""},{"location":"reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils","title":"<code>mainsequence.tdag.instrumentation.utils</code>","text":""},{"location":"reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils.TracerInstrumentator","title":"<code>TracerInstrumentator</code>","text":""},{"location":"reference/tdag/instrumentation/utils/#mainsequence.tdag.instrumentation.utils.TracerInstrumentator.build_tracer","title":"<code>build_tracer(service_name, origin, export_trace_to_console=False)</code>","text":"<p>buidl_tracer(\"Time Series\",name) :return:</p>"},{"location":"reference/tdag/time_series/persist_managers/","title":"persist_managers","text":""},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers","title":"<code>mainsequence.tdag.time_series.persist_managers</code>","text":""},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager","title":"<code>DataLakePersistManager</code>","text":"<p>               Bases: <code>PersistManager</code></p> <p>A class to manage data persistence in a local data lake.</p> <p>This class handles the storage and retrieval of time series data in a local file system, organized by date ranges and table hashes.</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initializes the DataLakePersistManager with configuration from environment variables.</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.set_already_run","title":"<code>set_already_run(already_run)</code>","text":"<p>This methos is critical as it control the level of introspection and avouids recursivity        This happens for example when TimeSeries.update_series_from_source(,): TimeSeries.update_series_from_source(latest_value,,**):     self.get_update_statistics() &lt;- will incurr in a circular refefence using local data late Args:     introspection:</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.DataLakePersistManager.verify_if_already_run","title":"<code>verify_if_already_run(ts)</code>","text":"<p>This method handles all the configuration and setup necessary when running a detached local data lake :param ts: :return:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager","title":"<code>PersistManager</code>","text":""},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.build_update_details","title":"<code>build_update_details(source_class_name)</code>","text":""},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.depends_on_connect","title":"<code>depends_on_connect(new_ts, is_api)</code>","text":"<p>Connects a time Serie as relationship in the DB</p> <p>Parameters:</p> Name Type Description Default <code>new_ts</code> <code>TimeSerie</code> required"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.get_pending_nodes","title":"<code>get_pending_nodes(table_id_list, filter_by_update_time)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_update_time</code> <code>bool</code> required"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.get_persisted_ts","title":"<code>get_persisted_ts()</code>","text":"<p>full Request of the persisted data should always default to DB :return:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.local_persist_exist_set_config","title":"<code>local_persist_exist_set_config(remote_table_hashed_name, local_configuration, remote_configuration, data_source, time_serie_source_code_git_hash, time_serie_source_code, remote_build_metadata)</code>","text":"<p>This method runs on initialization of the TimeSerie class. We also use it to retrieve the table if is already persisted :param config:</p> <p>:return:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.patch_build_configuration","title":"<code>patch_build_configuration(local_configuration, remote_configuration, remote_build_metadata)</code>","text":"<p>Args:     local_configuration:     remote_configuration:</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.patch_update_details","title":"<code>patch_update_details(local_hash_id=None, **kwargs)</code>","text":"<p>Patch update details ofr related_table</p> <p>Parameters:</p> Name Type Description Default <code>hash_id</code> required <code>kwargs</code> <code>{}</code>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.persist_updated_data","title":"<code>persist_updated_data(temp_df, historical_update_id, update_tracker=None, overwrite=False)</code>","text":"<p>Main update time series function, it is called from TimeSeries class</p> <p>Parameters:</p> Name Type Description Default <code>temp_df</code> <code>DataFrame</code> required <code>latest_value</code> required <code>session</code> required"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.synchronize_metadata","title":"<code>synchronize_metadata(meta_data, local_metadata, set_last_index_value=False, class_name=None)</code>","text":"<p>forces a synchronization between table and metadata :return:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.update_details_exist","title":"<code>update_details_exist()</code>","text":""},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.PersistManager.update_source_informmation","title":"<code>update_source_informmation(git_hash_id, source_code)</code>","text":"<p>Args:     git_hash_id:     source_code:</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.TimeScaleLocalPersistManager","title":"<code>TimeScaleLocalPersistManager</code>","text":"<p>               Bases: <code>PersistManager</code></p> <p>Main Controler to interacti with TimeSerie ORM</p>"},{"location":"reference/tdag/time_series/persist_managers/#mainsequence.tdag.time_series.persist_managers.TimeScaleLocalPersistManager.get_full_source_data","title":"<code>get_full_source_data(remote_table_hash_id, engine='pandas')</code>","text":"<p>Returns full stored data, uses multiprocessing to achieve several queries by rows and speed :return:</p>"},{"location":"reference/tdag/time_series/time_series/","title":"time_series","text":""},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series","title":"<code>mainsequence.tdag.time_series.time_series</code>","text":""},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie","title":"<code>APITimeSerie</code>","text":""},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.__init__","title":"<code>__init__(data_source_id, local_hash_id, data_source_local_lake=None)</code>","text":"<p>A time serie is uniquely identified in tdag by  data_source_id and table_name :param data_source_id: :param table_name:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.build_from_unique_identifier","title":"<code>build_from_unique_identifier(unique_identifier)</code>  <code>classmethod</code>","text":"<p>:param vam_source_name: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(asset_ranges_map)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_ranges</code> required"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.get_update_statistics","title":"<code>get_update_statistics(asset_symbols=None)</code>","text":"<p>getts latest value directly from querying the DB, args and kwargs are nedeed for datalake</p> <p>Parameters:</p> Name Type Description Default <code>args</code> required <code>kwargs</code> required"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.APITimeSerie.persist_data_to_local_lake","title":"<code>persist_data_to_local_lake(temp_df, update_tracker, latest_value, overwrite=False)</code>","text":"<p>Helper series to  persist data to a local lake for reading purposes :param temp_df: :param update_tracker: :param latest_value: :param overwrite: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer","title":"<code>ConfigSerializer</code>","text":""},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.deserialize_pickle_state","title":"<code>deserialize_pickle_state(state, include_vam_client_objects, data_source_id, graph_depth_limit, graph_depth, local_metadatas, ignore_pydantic=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> required <code>deserialize_pickle_state</code> required"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_config","title":"<code>rebuild_config(config, ignore_pydantic=False)</code>  <code>classmethod</code>","text":"<p>:param config: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_pydantic_model","title":"<code>rebuild_pydantic_model(details, state_kwargs=None)</code>  <code>classmethod</code>","text":"<p>If there is an state rebuild the configuration then the method to rebuild related objects is from state Args:     details:      state_kwargs: </p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_serialized_config","title":"<code>rebuild_serialized_config(config, time_serie_class_name)</code>  <code>classmethod</code>","text":"<p>rebulds configuration from config file, particularly Assets :param config:</p> <p>:param time_serie_class_name: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.rebuild_serialized_wrapper_dict","title":"<code>rebuild_serialized_wrapper_dict(time_series_dict_config)</code>  <code>classmethod</code>","text":"<p>rebuilds configuration from time_series Wrapper :param time_series_dict_config:</p> <p>:return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ConfigSerializer.serialize_init_kwargs","title":"<code>serialize_init_kwargs(kwargs)</code>","text":"<p>serializes  TimeSeries init_kwargs to be able to  persist in local configuration :param kwargs: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods","title":"<code>DataPersistanceMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(asset_ranges_map)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_ranges</code> required"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.flush_local_persisted","title":"<code>flush_local_persisted(flush_only_time_series=True, session=None)</code>","text":"<p>deletes  persisted data :param flush_sub_folders: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_last_observation","title":"<code>get_last_observation(asset_symbols=None)</code>","text":"<p>(1) Requests last observatiion from local persist manager (3) evaluates if last observation is consistent</p> <p>Parameters:</p> Name Type Description Default <code>asset_symbols</code> <code>Union[None, list]</code> <code>None</code>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_latest_update_by_assets_filter","title":"<code>get_latest_update_by_assets_filter(asset_symbols, last_update_per_asset)</code>","text":"<p>Gets the latest update from a symbol list :param asset_symbols: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.get_update_statistics","title":"<code>get_update_statistics(asset_symbols=None)</code>","text":"<p>getts latest value directly from querying the DB, args and kwargs are nedeed for datalake</p> <p>Parameters:</p> Name Type Description Default <code>args</code> required <code>kwargs</code> required"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.update_details_in_dependecy_tree","title":"<code>update_details_in_dependecy_tree(set_relation_tree=True, include_head=False, *args, **kwargs)</code>","text":"<p>updates schedule from all tree related time series :param schedule: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.DataPersistanceMethods.upsert_data","title":"<code>upsert_data(data_df)</code>","text":"<p>Updates and Insert data into DB :param data_df: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods","title":"<code>GraphNodeMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.get_all_local_dependencies","title":"<code>get_all_local_dependencies()</code>","text":"<p>get relation tree by ids in the graph :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.get_update_map","title":"<code>get_update_map(dependecy_map=None)</code>","text":"<p>Obtain all local time_series in the dependency graph by introspecting the code :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.GraphNodeMethods.set_relation_tree","title":"<code>set_relation_tree()</code>","text":"<p>Sets relationhsip in the DB :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.ModelList","title":"<code>ModelList</code>","text":"<p>               Bases: <code>list</code></p> <p>Necessary for configuration</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie","title":"<code>TimeSerie</code>","text":"<p>               Bases: <code>DataPersistanceMethods</code>, <code>GraphNodeMethods</code>, <code>TimeSerieRebuildMethods</code></p> <p>Pipeline</p> <pre><code>-__init__\n- _create_config\n\n- _init_db_properties_config\n- set_graph node\n</code></pre>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.hash_id","title":"<code>hash_id</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.__init__","title":"<code>__init__(init_meta=None, build_meta_data=None, local_kwargs_to_ignore=None, *args, **kwargs)</code>","text":"<p>Initializes the TimeSerie object with the provided metadata and configurations.</p> <p>This method sets up the time series object, loading the necessary configurations and metadata. If <code>is_local_relation_tree_set</code> is True, it avoids recalculating the relationship tree in schedulers, optimizing the process if the tree is already calculated during initialization.</p> <p>Parameters:</p> Name Type Description Default <code>init_meta</code> <code>dict</code> <p>Metadata for initializing the time series instance.</p> <code>None</code> <code>build_meta_data</code> <code>dict</code> <p>Metadata related to the building process of the time series.</p> <code>None</code> <code>local_kwargs_to_ignore</code> <code>list</code> <p>List of keyword arguments to ignore during configuration.</p> <code>None</code> <code>*args</code> <code>tuple</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.get_html_description","title":"<code>get_html_description()</code>","text":"<p>must return a descript on html tags so it can be readable and rendedered Returns:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.get_time_serie_source_code_git_hash","title":"<code>get_time_serie_source_code_git_hash(TimeSerieClass)</code>  <code>staticmethod</code>","text":"<p>Hashes a time serie source code</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.patch_build_configuration","title":"<code>patch_build_configuration()</code>","text":"<p>This method comes in handy when there is a change in VAM models extra configuration. This method will properly update the models on all the tree</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.pre_update_setting_routines","title":"<code>pre_update_setting_routines(scheduler, set_time_serie_queue_status, update_tree, metadata=None, local_metadata=None)</code>","text":"<p>Routines to execute previous to an update</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.run","title":"<code>run(debug_mode, *, update_tree=True, force_update=False, update_only_tree=False, remote_scheduler=None)</code>","text":"<p>Args:     debug_mode:     update_tree:     force_update:     update_only_tree:     remote_scheduler:</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.set_data_source","title":"<code>set_data_source(data_source=None)</code>","text":"<p>:return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.set_dependencies_df","title":"<code>set_dependencies_df()</code>","text":"<p>:return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerie.update_series_from_source","title":"<code>update_series_from_source(latest_value, *args, **kwargs)</code>","text":"<p>This method performs all the necessary logic to update our time series. The method should always return a DataFrame with the following characteristics:</p> <p>1) A unidimensional index where the index is of the type <code>DatetimeIndex</code> and the dates are in <code>pytz.utc</code>. 2) A multidimensional index that should always have 3 dimensions: <code>time_index</code> (with the same characteristics as before), <code>asset_symbol</code>, and <code>execution_venue_symbol</code>.</p> <p>Parameters:</p> Name Type Description Default <code>latest_value</code> <code>Union[None, datetime]</code> required <code>args</code> <code>()</code> <code>kwargs</code> <code>{}</code>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieConfigKwargs","title":"<code>TimeSerieConfigKwargs</code>","text":"<p>               Bases: <code>dict</code></p> <p>Necessary class for configuration</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods","title":"<code>TimeSerieRebuildMethods</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.get_minimum_required_depth_for_update","title":"<code>get_minimum_required_depth_for_update()</code>","text":"<p>Controls the minimum depth that needs to be rebuil</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.persist_to_pickle","title":"<code>persist_to_pickle(overwrite=False)</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.rebuild_and_set_from_local_hash_id","title":"<code>rebuild_and_set_from_local_hash_id(local_hash_id, data_source_id, set_dependencies_df=False, graph_depth_limit=1)</code>  <code>classmethod</code>","text":"<p>:param local_hash_id: :param data_source_id: :param set_dependencies_df: :param graph_depth_limit: :param local_metadatas: :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.rebuild_from_configuration","title":"<code>rebuild_from_configuration(local_hash_id, data_source)</code>  <code>classmethod</code>","text":"<p>:param serie_data_folder:</p> <p>:return: TimeSerie</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.run_in_debug_scheduler","title":"<code>run_in_debug_scheduler(break_after_one_update=True, run_head_in_main_process=True, wait_for_update=True, force_update=True, debug=True, update_tree=True, raise_exception_on_error=True)</code>","text":"<p>Args:     break_after_one_update:     run_head_in_main_process:     wait_for_update:     force_update:     debug:     update_tree:</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.set_state_with_sessions","title":"<code>set_state_with_sessions(include_vam_client_objects=True, graph_depth_limit=1000, local_metadatas=None, graph_depth=0)</code>","text":"<p>Method to set state after it was loaded from pickle.</p> <p>Parameters:</p> Name Type Description Default <code>include_vam_client_objects</code> <code>True</code> <code>graph_depth_limit</code> <code>1000</code> <code>metadatas</code> <code>pre-requestd dictionary of metadatas to speed calculation of rebuild of state</code> required <code>graph_depth</code> <code>0</code>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.TimeSerieRebuildMethods.update","title":"<code>update(update_tracker, debug_mode, raise_exceptions=True, update_tree=False, metadatas=None, update_only_tree=False, force_update=False, use_state_for_update=False)</code>","text":"<p>Main update method for time series that interacts with Graph node. Time series should be updated through this method only :param update_tree_kwargs: :param raise_exceptions: :param update_tree: :param scheduler: models.Scheduler :param metadatas: pre-requested metadatas to speed initiation of ts :return:</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie","title":"<code>WrapperTimeSerie</code>","text":"<p>               Bases: <code>TimeSerie</code></p> <p>A wrapper class for managing multiple TimeSerie objects.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.wrapped_latest_index_value","title":"<code>wrapped_latest_index_value: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get the latest values of all wrapped TimeSeries.</p> <p>Returns:     A dictionary with keys corresponding to TimeSerie keys and values being their latest values.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.wrapper_keys","title":"<code>wrapper_keys: List[str]</code>  <code>property</code>","text":"<p>Get the keys of all wrapped TimeSeries.</p> <p>Returns:     A list of keys for all wrapped TimeSeries.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.__init__","title":"<code>__init__(time_series_dict, *args, **kwargs)</code>","text":"<p>Initialize the WrapperTimeSerie.</p> <p>Args:     time_series_dict: Dictionary of TimeSerie objects.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore instance attributes from a pickled state.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.children_is_updating","title":"<code>children_is_updating()</code>","text":"<p>Check if any wrapped TimeSerie is currently updating.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_pandas_df_list_data_greater_than","title":"<code>get_pandas_df_list_data_greater_than(target_value, great_or_equal, thread=True)</code>","text":"<p>Get DataFrames from all wrapped TimeSeries greater than a target value.</p> <p>Args:     target_value: The target datetime value to compare against.     great_or_equal: Whether to include the target value (True) or not (False).     thread: Whether to use threading for parallel processing.</p> <p>Returns:     A dictionary with TimeSerie keys and their corresponding DataFrames or error messages.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_ts_as_pandas","title":"<code>get_ts_as_pandas()</code>","text":"<p>Get all wrapped TimeSeries as a list of pandas DataFrames.</p> <p>Returns:     A list of pandas DataFrames, one for each wrapped TimeSerie.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.get_wrapped","title":"<code>get_wrapped()</code>","text":"<p>Get all wrapped TimeSeries, including nested ones.</p> <p>Returns:     A list of all wrapped TimeSerie objects, including those nested in other WrapperTimeSeries.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.items","title":"<code>items()</code>","text":"<p>Get items of wrapped TimeSeries.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.pandas_df_concat_on_rows_by_key_between_dates","title":"<code>pandas_df_concat_on_rows_by_key_between_dates(start_date, great_or_equal, end_date, less_or_equal, thread=False, asset_symbols=None, return_as_list=False, key_date_filter=None)</code>","text":"<p>Concatenate DataFrames from all wrapped TimeSeries between given dates.</p> <p>Args:     start_date: The start date for the data range.     great_or_equal: Whether to include the start date (True) or not (False).     end_date: The end date for the data range.     less_or_equal: Whether to include the end date (True) or not (False).     thread: Whether to use threading for parallel processing.     asset_symbols: asset_symbol filter     return_as_list: If True, return a dictionary of DataFrames instead of concatenating.    key_date_filter: Concatenate DataFrames only for key date filter. Returns:     A concatenated DataFrame or a dictionary of DataFrames if return_as_list is True.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.pandas_df_concat_on_rows_by_key_greater_than","title":"<code>pandas_df_concat_on_rows_by_key_greater_than(target_value, great_or_equal, thread=False, return_as_list=False, columns=None, *args, **kwargs)</code>","text":"<p>Concatenate DataFrames from all wrapped TimeSeries greater than a target value.</p> <p>Args:     target_value: The latest datetime value to compare against.     great_or_equal: Whether to include the target value (True) or not (False).     thread: Whether to use threading for parallel processing.     return_as_list: If True, return a dictionary of DataFrames instead of concatenating.     columns: Optional list of columns to include.</p> <p>Returns:     A concatenated DataFrame or a dictionary of DataFrames if return_as_list is True.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.set_local_persist_manager_if_not_set","title":"<code>set_local_persist_manager_if_not_set()</code>","text":"<p>Set local persist manager for all wrapped TimeSeries.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.set_state_with_sessions","title":"<code>set_state_with_sessions(include_vam_client_objects, graph_depth_limit, graph_depth, local_metadatas=None)</code>","text":"<p>Set state with sessions for all wrapped TimeSeries.</p> <p>Args:     include_vam_client_objects: Whether to include asset ORM objects.     graph_depth_limit: The maximum depth of the graph to traverse.     graph_depth: The current depth in the graph.     local_metadatas: Optional metadata dictionary.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.update_series_from_source","title":"<code>update_series_from_source(latest_value, *args, **kwargs)</code>","text":"<p>Implemented in the wrapped nodes</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.WrapperTimeSerie.values","title":"<code>values()</code>","text":"<p>Get values of wrapped TimeSeries.</p>"},{"location":"reference/tdag/time_series/time_series/#mainsequence.tdag.time_series.time_series.hash_signature","title":"<code>hash_signature(dictionary)</code>","text":"<p>MD5 hash of a dictionary used to hash the local annd remote configuration of tables :param dictionary: :return:</p>"},{"location":"reference/tdag/time_series/utils/","title":"utils","text":""},{"location":"reference/tdag/time_series/utils/#mainsequence.tdag.time_series.utils","title":"<code>mainsequence.tdag.time_series.utils</code>","text":""},{"location":"reference/tdag/time_series/update/api/","title":"api","text":""},{"location":"reference/tdag/time_series/update/api/#mainsequence.tdag.time_series.update.api","title":"<code>mainsequence.tdag.time_series.update.api</code>","text":""},{"location":"reference/tdag/time_series/update/ray_manager/","title":"ray_manager","text":""},{"location":"reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager","title":"<code>mainsequence.tdag.time_series.update.ray_manager</code>","text":""},{"location":"reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager.RayUpdateManager","title":"<code>RayUpdateManager</code>","text":"<p>Controller for interactions with ray cluster</p>"},{"location":"reference/tdag/time_series/update/ray_manager/#mainsequence.tdag.time_series.update.ray_manager.RayUpdateManager.get_results_from_futures_list","title":"<code>get_results_from_futures_list(futures)</code>","text":"<p>should be a list of futures objects ray.remote() Args:     futures ():</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/update/scheduler/","title":"scheduler","text":""},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler","title":"<code>mainsequence.tdag.time_series.update.scheduler</code>","text":""},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.SchedulerUpdater","title":"<code>SchedulerUpdater</code>","text":""},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.SchedulerUpdater.start","title":"<code>start(debug=False, update_tree=True, break_after_one_update=False, raise_exception_on_error=False, update_extra_kwargs=None, run_head_in_main_process=False, force_update=False, sequential_update=False, update_only_tree=False, api_port=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>If True, all dependencies of a time series run in the same process. Defaults to False.</p> <code>False</code> <code>update_tree</code> <code>bool or dict</code> <p>If True, updates the tree of dependent tasks.</p> <code>True</code> <code>break_after_one_update</code> <code>bool</code> <p>If True, the process stops after the first update cycle. Defaults to False.</p> <code>False</code> <code>raise_exception_on_error</code> <code>bool</code> <p>If True, raises an exception on encountering an error during execution. Otherwise, errors are handled silently. Defaults to False.</p> <code>False</code> <code>update_extra_kwargs</code> <code>dict or None</code> <p>Additional parameters (if any) to pass along when updating. Defaults to None.</p> <code>None</code> <code>run_head_in_main_process</code> <code>bool</code> <p>If True, each \"head\" time series is run in the main scheduler process. Useful for debugging. Defaults to False.</p> <code>False</code> <code>force_update</code> <code>bool</code> <p>If True, forces an update run even if it's not required. Defaults to False.</p> <code>False</code> <code>sequential_update</code> <code>bool</code> <p>If True, runs each \"head\" time series one by one instead of in parallel. Defaults to False.</p> <code>False</code> <code>update_only_tree</code> <code>bool</code> <p>If True, only the dependency tree is updated without fully processing every step. Defaults to False.</p> <code>False</code> <code>api_port</code> <code>int or None</code> <p>The port on which any exposed APIs should run. If None, no API is exposed. Defaults to None.</p> <code>None</code>"},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor","title":"<code>TimeSerieHeadUpdateActor</code>","text":""},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor.__init__","title":"<code>__init__(local_hash_id, data_source_id, scheduler, debug, update_tree, update_extra_kwargs, remote_table_hashed_name)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>hash_id</code> required <code>scheduler</code> <code>Scheduler</code> required <code>debug</code> required <code>update_tree</code> required <code>update_extra_kwargs</code> required"},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.TimeSerieHeadUpdateActor.run_one_step_update","title":"<code>run_one_step_update(force_update=False, update_only_tree=False)</code>","text":"<p>Main update Method for a time serie Head</p>"},{"location":"reference/tdag/time_series/update/scheduler/#mainsequence.tdag.time_series.update.scheduler.set_data_source","title":"<code>set_data_source(pod_source=None, tdag_detached=False, override_all=False)</code>","text":"<p>:param override_all: :return:</p>"},{"location":"reference/tdag/time_series/update/update_methods/","title":"update_methods","text":""},{"location":"reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods","title":"<code>mainsequence.tdag.time_series.update.update_methods</code>","text":""},{"location":"reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.TimeSerieUpdater","title":"<code>TimeSerieUpdater</code>","text":""},{"location":"reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.update_remote_from_hash_id","title":"<code>update_remote_from_hash_id(*args, **kwargs)</code>","text":"<p>Ray wrapper for session update :param args: :param kwargs: :return:</p>"},{"location":"reference/tdag/time_series/update/update_methods/#mainsequence.tdag.time_series.update.update_methods.update_remote_from_hash_id_local","title":"<code>update_remote_from_hash_id_local(telemetry_carrier, scheduler_uid, local_hash_id, data_source_id)</code>","text":"<p>Args:     in_update_tree_node_uid ():     update_tree_kwargs ():     execution_start ():     telemtry_carrier ():     update_priority ():     hash_id ():</p> <p>Returns:</p>"},{"location":"reference/tdag/time_series/update/utils/","title":"utils","text":""},{"location":"reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils","title":"<code>mainsequence.tdag.time_series.update.utils</code>","text":""},{"location":"reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.UpdateInterface","title":"<code>UpdateInterface</code>","text":"<p>Helper class to avoid calling ray in other modules</p>"},{"location":"reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.get_available_port","title":"<code>get_available_port(port_range=(8000, 8090))</code>","text":"<p>Check if the given port is free, and if not, find an available port within the range.</p>"},{"location":"reference/tdag/time_series/update/utils/#mainsequence.tdag.time_series.update.utils.is_port_free","title":"<code>is_port_free(port)</code>","text":"<p>Check if the port is free on the local machine.</p>"},{"location":"reference/tdag_client/models/","title":"models","text":""},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models","title":"<code>mainsequence.tdag_client.models</code>","text":""},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers","title":"<code>DynamicTableHelpers</code>","text":""},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.copy_table_data_to_other_orm","title":"<code>copy_table_data_to_other_orm(target_database_uri, target_admin_user, target_admin_password, target_orm_url_api_root, target_gcp_credentials_path, hash_id_contains, source_database_uri, source_orm_url_api_root, source_orm_admin_user, source_orm_admin_password, source_gcp_credentials_path, start_date, end_date, great_or_equal, less_or_equal, overwrite=False, copy_descendants=False, exclude_hash_ids=None)</code>","text":"<p>This function copies table data from an ORM to another one example: copy_database</p> <p>Parameters:</p> Name Type Description Default <code>target_database_uri</code> <code>str</code> required <code>target_admin_user</code> <code>str</code> required <code>target_admin_password</code> <code>str</code> required <code>target_orm_url_api_root</code> <code>str</code> required <code>hash_id_contains</code> <code>str</code> required <code>start_date</code> <code>datetime</code> required <code>end_date</code> <code>datetime</code> required <code>great_or_equal</code> <code>bool</code> required <code>less_or_equal</code> <code>bool</code> required <code>overwrite</code> <code>False</code>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.create","title":"<code>create(metadata_kwargs)</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.get_update_statistics","title":"<code>get_update_statistics(hash_id)</code>","text":"<p>Gets latest value from Hash_id :param hash_id: :type hash_id: :return: :rtype:i</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.patch","title":"<code>patch(metadata, timeout=None, *args, **kwargs)</code>","text":"<p>Main patch method :return: :rtype:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.set_compression_policy","title":"<code>set_compression_policy(metadata, interval)</code>","text":"<p>:param hash_id: :type hash_id: :return: :rtype:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.time_serie_exist_in_db","title":"<code>time_serie_exist_in_db(hash_id)</code>","text":""},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.DynamicTableHelpers.upsert_data_into_table","title":"<code>upsert_data_into_table(metadata, local_metadata, historical_update_id, data, overwrite, data_source, logger=logger)</code>","text":"<p>1) Build or get metadata 2) build table configuration relationships</p> <p>Parameters:</p> Name Type Description Default <code>build_meta_data</code> required <code>build_configuration</code> required <code>data</code> <code>DataFrame</code> required"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.Scheduler","title":"<code>Scheduler</code>","text":"<p>               Bases: <code>BaseTdagPydanticModel</code>, <code>BaseObject</code></p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.Scheduler.stop_heart_beat","title":"<code>stop_heart_beat()</code>","text":"<p>Stop the heartbeat gracefully.</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerie","title":"<code>TimeSerie</code>","text":"<p>               Bases: <code>BaseObject</code></p> <p>Main Methods of a standard time serie by hash_id</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate","title":"<code>TimeSerieLocalUpdate</code>","text":"<p>               Bases: <code>BaseObject</code></p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.create_historical_update","title":"<code>create_historical_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:param args: :type args: :param kwargs: :type kwargs: :return: :rtype:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.get_mermaid_dependency_diagram","title":"<code>get_mermaid_dependency_diagram(local_hash_id, data_source_id, desc=True, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param local_hash_id: :return:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieLocalUpdate.post_data_frame_in_chunks","title":"<code>post_data_frame_in_chunks(serialized_data_frame, logger, chunk_size=50000, local_metadata=None, data_source=None, index_names=None, time_index_name='timestamp', overwrite=False, JSON_COMPRESSED_PREFIX='base64-gzip', session=None)</code>  <code>classmethod</code>","text":"<p>Sends a large DataFrame to a Django backend in multiple chunks.</p> <p>:param serialized_data_frame: The DataFrame to upload. :param url: The endpoint URL (e.g. https://yourapi.com/upload-chunk/). :param chunk_size: Number of rows per chunk. :param local_metadata: General metadata dict you want to send with each chunk. :param data_source: Additional info about the source of the data. :param index_names: Index columns in the DataFrame. :param time_index_name: The column name used for time indexing. :param overwrite: Boolean indicating whether existing data should be overwritten. :param JSON_COMPRESSED_PREFIX: String indicating the compression scheme in your JSON payload. :param session: Optional requests.Session() for connection reuse.</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode","title":"<code>TimeSerieNode</code>","text":"<p>               Bases: <code>BaseTdagPydanticModel</code>, <code>BaseObject</code></p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.depends_on_connect","title":"<code>depends_on_connect(target_class_name, source_local_hash_id, target_local_hash_id, source_data_source_id, target_data_source_id, target_human_readable)</code>  <code>classmethod</code>","text":"<p>Connects and build relationship</p> <p>Parameters:</p> Name Type Description Default <code>source_hash_id</code> required <code>target_hash_id</code> required <code>target_class_name</code> <code>str</code> required <code>target_human_readable</code> <code>str</code> required"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.depends_on_connect_remote_table","title":"<code>depends_on_connect_remote_table(source_hash_id, source_local_hash_id, source_data_source_id, target_data_source_id, target_local_hash_id)</code>  <code>classmethod</code>","text":""},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.TimeSerieNode.patch_build_configuration","title":"<code>patch_build_configuration(remote_table_patch, build_meta_data, data_source_id, local_table_patch)</code>  <code>classmethod</code>","text":"<p>Args:     remote_table_patch:     local_table_patch:</p> <p>Returns:</p>"},{"location":"reference/tdag_client/models/#mainsequence.tdag_client.models.none_if_backend_detached","title":"<code>none_if_backend_detached(func)</code>","text":"<p>Decorator that evaluates BACKEND_DETACHED before executing the function. If BACKEND_DETACHED() returns True, the function is skipped, and None is returned. Otherwise, the function is executed as normal.</p> <p>It supports regular functions, property methods, classmethods, and staticmethods.</p>"},{"location":"reference/tdag_client/utils/","title":"utils","text":""},{"location":"reference/tdag_client/utils/#mainsequence.tdag_client.utils","title":"<code>mainsequence.tdag_client.utils</code>","text":""},{"location":"reference/tdag_client/utils/#mainsequence.tdag_client.utils.LazyConstants","title":"<code>LazyConstants</code>","text":"<p>               Bases: <code>dict</code></p> <p>Class Method to load constants only once they are called. this minimizes the calls to the API</p>"},{"location":"reference/tdag_client/utils/#mainsequence.tdag_client.utils.chunks","title":"<code>chunks(lst, n)</code>","text":"<p>Yield successive n-sized chunks from lst.</p>"},{"location":"reference/tdag_client/utils/#mainsequence.tdag_client.utils.inflate_json_compresed_column","title":"<code>inflate_json_compresed_column(compressed_series)</code>","text":"<p>Inflates a compressed json_compressed series</p> <p>Parameters:</p> Name Type Description Default <code>compressed_series</code> <code>Series</code> required"},{"location":"reference/tdag_client/utils/#mainsequence.tdag_client.utils.is_process_running","title":"<code>is_process_running(pid)</code>","text":"<p>Check if a process with the given PID is running.</p> <p>Args:     pid (int): The process ID to check.</p> <p>Returns:     bool: True if the process is running, False otherwise.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/","title":"local_data_lake","text":""},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake","title":"<code>mainsequence.tdag_client.data_sources_interfaces.local_data_lake</code>","text":""},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface","title":"<code>DataLakeInterface</code>","text":""},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.build_time_and_symbol_filter","title":"<code>build_time_and_symbol_filter(start_date=None, great_or_equal=True, less_or_equal=True, end_date=None, asset_symbols=None)</code>  <code>staticmethod</code>","text":"<p>Build hashable parquet filters based on the parameters.</p> <p>Args:     metadata (dict): Metadata dictionary, not used for filtering here but included for extensibility.     start_date (datetime.datetime, optional): Start date for filtering.     great_or_equal (bool): Whether the start date condition is <code>&gt;=</code> or <code>&gt;</code>.     less_or_equal (bool): Whether the end date condition is <code>&lt;=</code> or <code>&lt;</code>.     end_date (datetime.datetime, optional): End date for filtering.     asset_symbols (list, optional): List of asset symbols to filter on.</p> <p>Returns:     tuple: Hashable parquet filters for use with pandas or pyarrow.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(table_name, asset_ranges_map)</code>","text":"<p>:param table_name: :param asset_ranges_map: :return:</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.persist_datalake","title":"<code>persist_datalake(data, overwrite, table_name, time_index_name, index_names)</code>","text":"<p>Partition per week , do not partition per asset_symbol as system only allows 1024 partittions Args:     data:</p> <p>Returns:</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.DataLakeInterface.query_datalake","title":"<code>query_datalake(table_name, filters=None)</code>","text":"<p>Queries the data lake for time series data.</p> <p>If the table_hash is in nodes_to_persist, it retrieves or creates the data. Otherwise, it updates the series from the source.</p> <p>Args:     ts: The time series object.     latest_value: The latest timestamp to query from.     symbol_list: List of symbols to retrieve data for.     great_or_equal: Boolean flag for date comparison.     update_tree_kwargs: Dictionary of kwargs for updating the tree.</p> <p>Returns:     pd.DataFrame: The queried data.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.memory_usage_exceeds_limit","title":"<code>memory_usage_exceeds_limit(max_usage_percentage)</code>","text":"<p>Checks if the current memory usage exceeds the given percentage of total memory.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/local_data_lake/#mainsequence.tdag_client.data_sources_interfaces.local_data_lake.read_full_data","title":"<code>read_full_data(file_path, filters=None, use_s3_if_available=False, max_memory_usage=80)</code>  <code>cached</code>","text":"<p>Cached access to static datalake file</p>"},{"location":"reference/tdag_client/data_sources_interfaces/timescale/","title":"timescale","text":""},{"location":"reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale","title":"<code>mainsequence.tdag_client.data_sources_interfaces.timescale</code>","text":""},{"location":"reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.direct_data_from_db","title":"<code>direct_data_from_db(metadata, connection_uri, start_date=None, great_or_equal=True, less_or_equal=True, end_date=None, columns=None, asset_symbols=None)</code>","text":"<p>Connects directly to the DB without passing through the ORM to speed up calculations.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>Metadata containing table and column details.</p> required <code>connection_config</code> <code>dict</code> <p>Connection configuration for the database.</p> required <code>start_date</code> <code>datetime</code> <p>The start date for filtering. If None, no lower bound is applied.</p> <code>None</code> <code>great_or_equal</code> <code>bool</code> <p>Whether the start_date filter is inclusive (&gt;=). Defaults to True.</p> <code>True</code> <code>less_or_equal</code> <code>bool</code> <p>Whether the end_date filter is inclusive (&lt;=). Defaults to True.</p> <code>True</code> <code>end_date</code> <code>datetime</code> <p>The end date for filtering. If None, no upper bound is applied.</p> <code>None</code> <code>columns</code> <code>list</code> <p>Specific columns to select. If None, all columns are selected.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Data from the table as a pandas DataFrame, optionally filtered by date range.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.direct_table_update","title":"<code>direct_table_update(table_name, serialized_data_frame, overwrite, grouped_dates, time_index_name, index_names, table_is_empty, table_index_names, time_series_orm_db_connection=None, use_chunks=True, num_threads=4)</code>","text":"<p>Updates the database table with the given DataFrame.</p> <p>Parameters: - table_name: Name of the database table. - serialized_data_frame: DataFrame containing the data to insert. - overwrite: If True, existing data in the date range will be deleted before insertion. - time_index_name: Name of the time index column. - index_names: List of index column names. - table_is_empty: If True, the table is empty. - time_series_orm_db_connection: Database connection string. - use_chunks: If True, data will be inserted in chunks using threads. - num_threads: Number of threads to use when use_chunks is True.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.filter_by_assets_ranges","title":"<code>filter_by_assets_ranges(table_name, asset_ranges_map, index_names, data_source, column_types)</code>","text":"<p>Query time series data dynamically based on asset ranges.</p> <p>Args:     table_name (str): The name of the table to query.     asset_ranges_map (dict): A dictionary where keys are asset symbols and values are dictionaries containing:                              - 'start_date' (datetime): The start date of the range.                              - 'start_date_operand' (str): The SQL operand for the start date (e.g., '&gt;=' or '&gt;').                              - 'end_date' (datetime or None): The end date of the range.     index_names (list): List of column names to set as the DataFrame index.     data_source: A data source object with a method <code>get_connection_uri()</code> to get the database connection URI.</p> <p>Returns:     pd.DataFrame: A Pandas DataFrame with the queried data, indexed by the specified columns.</p>"},{"location":"reference/tdag_client/data_sources_interfaces/timescale/#mainsequence.tdag_client.data_sources_interfaces.timescale.process_and_update_table","title":"<code>process_and_update_table(serialized_data_frame, metadata, grouped_dates, data_source, index_names, time_index_name, logger, overwrite=False, JSON_COMPRESSED_PREFIX=None)</code>","text":"<p>Process a serialized DataFrame, handle overwriting, and update a database table.</p> <p>Args:     serialized_data_frame (pd.DataFrame): The DataFrame to process and update.     metadata (dict): Metadata about the table, including table configuration.     grouped_dates (list): List of grouped dates to assist with the update.     data_source (object): A data source object with a <code>get_connection_uri</code> method.     index_names (list): List of index column names.     time_index_name (str): The name of the time index column.     overwrite (bool): Whether to overwrite the table or not.     JSON_COMPRESSED_PREFIX (list): List of prefixes to identify JSON-compressed columns.</p> <p>Returns:     None</p>"},{"location":"reference/vam_client/local_vault/","title":"local_vault","text":""},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault","title":"<code>mainsequence.vam_client.local_vault</code>","text":""},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.decrypt_secrets","title":"<code>decrypt_secrets(encrypted_secrets)</code>","text":"<p>Decrypt the secrets JSON.</p>"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.encrypt_secrets","title":"<code>encrypt_secrets(secrets)</code>","text":"<p>Encrypt the secrets JSON.</p>"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.generate_key","title":"<code>generate_key()</code>","text":"<p>Generate an encryption key and save it to a file.</p>"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.get_all_entries_in_vault_for_venue","title":"<code>get_all_entries_in_vault_for_venue(execution_venue_symbol)</code>","text":"<p>Retrieve all entries from the database for a specific execution venue.</p>"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.get_secrets_for_account_id","title":"<code>get_secrets_for_account_id(account_id)</code>","text":"<p>Gets the secrets from the vault from an specific account_id</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> required"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.load_key","title":"<code>load_key()</code>","text":"<p>Load the encryption key from the file.</p>"},{"location":"reference/vam_client/local_vault/#mainsequence.vam_client.local_vault.validate_secrets","title":"<code>validate_secrets(secrets, execution_venue_symbol)</code>","text":"<p>Validate that secrets conform to the schema for the given execution venue.</p>"},{"location":"reference/vam_client/models/","title":"models","text":""},{"location":"reference/vam_client/models/#mainsequence.vam_client.models","title":"<code>mainsequence.vam_client.models</code>","text":""},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.AccountMixin","title":"<code>AccountMixin</code>","text":"<p>               Bases: <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.AccountMixin.build_rebalance","title":"<code>build_rebalance(latest_holdings, tolerance, change_cash_asset_to_currency_asset=None)</code>","text":"<p>:param latest_holdings: :type latest_holdings: :param tolerance: :type tolerance: :param change_cash_asset_to_currency_asset: :type change_cash_asset_to_currency_asset: :return:</p> <p>rebalance[] = {\"rebalance\":{\"quantity\":, \"reference_price\":, \"reference_notional\":}, \"asset\":Asset} <p>:rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin","title":"<code>AssetMixin</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin.batch_upsert","title":"<code>batch_upsert(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.AssetMixin.get_ccxt_symbol","title":"<code>get_ccxt_symbol(settlement_symbol=None)</code>","text":"<p>Gets the right symbol for ccxt</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm","title":"<code>BaseObjectOrm</code>","text":""},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.create","title":"<code>create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.patch_by_id","title":"<code>patch_by_id(instance_id, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.BaseObjectOrm.update_or_create","title":"<code>update_or_create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPositions","title":"<code>ExecutionPositions</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPositions.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_signal_hash_id, positions_list, positions_time, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPrediction","title":"<code>ExecutionPrediction</code>","text":"<p>               Bases: <code>BaseObjectOrm</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.ExecutionPrediction.add_prediction_from_time_serie","title":"<code>add_prediction_from_time_serie(time_serie_hash_id, prediction_time, symbol_to_search_map, predictions, human_readable_name=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.HistoricalWeights","title":"<code>HistoricalWeights</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.HistoricalWeights.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_hash_id, positions_list, weights_date, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails","title":"<code>TargetPortfolioFrontEndDetails</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails.create","title":"<code>create(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.TargetPortfolioFrontEndDetails.create_or_update","title":"<code>create_or_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund","title":"<code>VirtualFund</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund.build_rebalance_from_target_weights","title":"<code>build_rebalance_from_target_weights(target_execution_postitions, positions_prices, absolute_rebalance_weight_limit=0.02)</code>","text":""},{"location":"reference/vam_client/models/#mainsequence.vam_client.models.VirtualFund.sanitize_target_weights_for_execution_venue","title":"<code>sanitize_target_weights_for_execution_venue(target_weights)</code>","text":"<p>This functions switches assets from main net to test net to guarante consistency in the recording of trades and orders Args:     target_weights:{asset_id:WeightExecutionPosition}</p> <p>Returns:</p>"},{"location":"reference/vam_client/models_alpaca/","title":"models_alpaca","text":""},{"location":"reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca","title":"<code>mainsequence.vam_client.models_alpaca</code>","text":""},{"location":"reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.AlpacaAccount","title":"<code>AlpacaAccount</code>","text":"<p>               Bases: <code>AccountMixin</code>, <code>AlpacaBaseObject</code></p>"},{"location":"reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.AlpacaAccount.sync_funds","title":"<code>sync_funds(target_trade_time=None, target_holdings=None, holdings_source=None, target_weights=None, end_of_execution_time=None, timeout=None, is_trade_snapshot=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>account_data</code> required <code>target_trade_time</code> <code>Union[None, datetime]</code> <code>None</code> <code>target_holdings</code> <code>Union[None, dict]</code> <code>None</code> <code>holdings_source</code> <code>Union[str, None]</code> <code>None</code> <code>end_of_execution_time</code> <code>Union[None, datetime]</code> <code>None</code>"},{"location":"reference/vam_client/models_alpaca/#mainsequence.vam_client.models_alpaca.build_alpaca_account_from_keys","title":"<code>build_alpaca_account_from_keys(execution_venue, api_key, api_secret, account_id)</code>","text":"<p>Args:     execution_venue:     api_key:     api_secret:</p> <p>Returns:</p>"},{"location":"reference/vam_client/models_binance/","title":"models_binance","text":""},{"location":"reference/vam_client/models_binance/#mainsequence.vam_client.models_binance","title":"<code>mainsequence.vam_client.models_binance</code>","text":""},{"location":"reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BaseFuturesAccount","title":"<code>BaseFuturesAccount</code>","text":"<p>               Bases: <code>AccountMixin</code>, <code>BinanceBaseObject</code></p>"},{"location":"reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BaseFuturesAccount.sync_funds","title":"<code>sync_funds(target_trade_time=None, target_holdings=None, holdings_source=None, target_weights=None, end_of_execution_time=None, timeout=None, is_trade_snapshot=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>account_data</code> required <code>target_trade_time</code> <code>Union[None, datetime]</code> <code>None</code> <code>target_holdings</code> <code>Union[None, dict]</code> <code>None</code> <code>holdings_source</code> <code>Union[str, None]</code> <code>None</code> <code>end_of_execution_time</code> <code>Union[None, datetime]</code> <code>None</code>"},{"location":"reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BinanceAssetFutureUSDM","title":"<code>BinanceAssetFutureUSDM</code>","text":"<p>               Bases: <code>FutureUSDMMixin</code>, <code>BinanceBaseObject</code></p>"},{"location":"reference/vam_client/models_binance/#mainsequence.vam_client.models_binance.BinanceAssetFutureUSDM.batch_upsert_from_base_quote","title":"<code>batch_upsert_from_base_quote(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"reference/vam_client/models_helpers/","title":"models_helpers","text":""},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers","title":"<code>mainsequence.vam_client.models_helpers</code>","text":""},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AccountMixin","title":"<code>AccountMixin</code>","text":"<p>               Bases: <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AccountMixin.build_rebalance","title":"<code>build_rebalance(latest_holdings, tolerance, change_cash_asset_to_currency_asset=None)</code>","text":"<p>:param latest_holdings: :type latest_holdings: :param tolerance: :type tolerance: :param change_cash_asset_to_currency_asset: :type change_cash_asset_to_currency_asset: :return:</p> <p>rebalance[] = {\"rebalance\":{\"quantity\":, \"reference_price\":, \"reference_notional\":}, \"asset\":Asset} <p>:rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin","title":"<code>AssetMixin</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin.batch_upsert","title":"<code>batch_upsert(asset_config_list, execution_venue_symbol, asset_type, timeout=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>asset_config_list</code> <code>list</code> required <code>execution_venue_symbol</code> <code>str</code> required <code>asset_type</code> <code>str</code> required"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.AssetMixin.get_ccxt_symbol","title":"<code>get_ccxt_symbol(settlement_symbol=None)</code>","text":"<p>Gets the right symbol for ccxt</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm","title":"<code>BaseObjectOrm</code>","text":""},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.create","title":"<code>create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.patch_by_id","title":"<code>patch_by_id(instance_id, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.BaseObjectOrm.update_or_create","title":"<code>update_or_create(timeout=None, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPositions","title":"<code>ExecutionPositions</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPositions.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_signal_hash_id, positions_list, positions_time, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPrediction","title":"<code>ExecutionPrediction</code>","text":"<p>               Bases: <code>BaseObjectOrm</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.ExecutionPrediction.add_prediction_from_time_serie","title":"<code>add_prediction_from_time_serie(time_serie_hash_id, prediction_time, symbol_to_search_map, predictions, human_readable_name=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.HistoricalWeights","title":"<code>HistoricalWeights</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.HistoricalWeights.add_from_time_serie","title":"<code>add_from_time_serie(time_serie_hash_id, positions_list, weights_date, comments=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>:param session: :return:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails","title":"<code>TargetPortfolioFrontEndDetails</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails.create","title":"<code>create(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.TargetPortfolioFrontEndDetails.create_or_update","title":"<code>create_or_update(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>:return: :rtype:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund","title":"<code>VirtualFund</code>","text":"<p>               Bases: <code>BaseObjectOrm</code>, <code>BaseVamPydanticModel</code></p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund.build_rebalance_from_target_weights","title":"<code>build_rebalance_from_target_weights(target_execution_postitions, positions_prices, absolute_rebalance_weight_limit=0.02)</code>","text":""},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.VirtualFund.sanitize_target_weights_for_execution_venue","title":"<code>sanitize_target_weights_for_execution_venue(target_weights)</code>","text":"<p>This functions switches assets from main net to test net to guarante consistency in the recording of trades and orders Args:     target_weights:{asset_id:WeightExecutionPosition}</p> <p>Returns:</p>"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.get_model_class","title":"<code>get_model_class(model_class)</code>","text":"<p>Reverse look from model class by name</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <code>str</code> required"},{"location":"reference/vam_client/models_helpers/#mainsequence.vam_client.models_helpers.sync_account_funds","title":"<code>sync_account_funds(account, *args, **kwargs)</code>","text":"<p>This functions takes and Account and makes the correct sync  by quering the right account objectt</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>Account</code> required"},{"location":"reference/vam_client/utils/","title":"utils","text":""},{"location":"reference/vam_client/utils/#mainsequence.vam_client.utils","title":"<code>mainsequence.vam_client.utils</code>","text":""},{"location":"reference/vam_client/utils/#mainsequence.vam_client.utils.LazyConstants","title":"<code>LazyConstants</code>","text":"<p>               Bases: <code>dict</code></p> <p>Class Method to load constants only once they are called. this minimizes the calls to the API</p>"},{"location":"reference/vam_client/utils/#mainsequence.vam_client.utils.LazyConstants.to_attr_dict","title":"<code>to_attr_dict(data)</code>","text":"<p>Recursively convert a Python dict into an object that allows dot-notation access. Non-dict values (e.g., int, str, list) are returned as-is; dicts become _AttrDict.</p>"},{"location":"reference/vam_client/utils/#mainsequence.vam_client.utils.build_account_for_venue","title":"<code>build_account_for_venue(execution_venue, account_id, api_key, api_secret)</code>","text":"<p>Creates the account for a venue</p>"},{"location":"reference/vam_client/utils/#mainsequence.vam_client.utils.build_accounts_for_venues","title":"<code>build_accounts_for_venues(venue_symbols, rebuild_assets=True)</code>","text":"<p>Creates all the accounts for a list of venues in VAM</p>"},{"location":"reference/vam_client/maintenance/accounts/","title":"accounts","text":""},{"location":"reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts","title":"<code>mainsequence.vam_client.maintenance.accounts</code>","text":""},{"location":"reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts.AccountLooper","title":"<code>AccountLooper</code>","text":""},{"location":"reference/vam_client/maintenance/accounts/#mainsequence.vam_client.maintenance.accounts.AccountLooper.update_account_loop","title":"<code>update_account_loop(account, logger)</code>  <code>staticmethod</code>","text":"<p>This methoods runs one account update (1) sync funds (2) Very risk parameters for an unwind</p> <p>Parameters:</p> Name Type Description Default <code>account</code> <code>Account</code> required"}]}